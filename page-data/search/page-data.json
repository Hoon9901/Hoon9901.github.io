{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n인프런 강의(Spring Boot JWT Tutorial)를 수강하며, 내용들을 기록한 페이지입니다.\n\n- 배우는 것\n    - Spring Boot를 이용한 JWT 인증, 인가 구현\n    - Spring Security 기초\n    - 회원가입, 로그인, 권한로직\n\n# JWT 소개 ([JWT.io](http://JWT.io) [홈페이지](https://jwt.io))\n\n---\n\n![Untitled](1-1.png)\n\nJWT 는 Json 객체를 사용하여 토큰 자체에 정보들을 저장하고 있는 Web Token 이라 할 수 있다.\n\n특히, JWT를 이용하는 방식은 헤비하지 않고 아주 간편하고 쉽게 적응할 수 있다.\n\n- JWT 는 Header, Payload, Signature  3개의 부분으로 구성되어 있다.\n    - Header : Signature 를 해싱하기 위한 알고리즘 정보들이 담김\n    - Payload :  서버와 클라이언트가 주고받는, 시스템에서 실제로 사용될 정보에 대한 내용들을 담고있다.\n    - Signature : 토큰의 유효성 검증을 위한 문자열\n- 장점\n    - 중앙의 인증서버, 데이터 스토어에 대한 의존성 없음, 수평확장에 유리\n    - Base64 URL Safe Encoding  > URL, Cookie, Header 모두 사용 가능\n- 단점\n    - Payload 의 정보가 많아지면 네트워크 사용량 증가, 데이터 설계 고려 필요\n    - 토큰이 클라이언트에 저장, 서버에서 클라이언트의 토큰을 조작할 수 없음\n\n## 프로젝트 생성\n\n---\n\n### 1. 스프링 이니셜라이저를 통한 프로젝트 생성\n\n![Untitled](1-2.png)\n\n- 프로젝트 메타데이터를 입력한다\n- 자바 버전은 8\n- 빌드 도구는 Gradle\n\n![Untitled](1-3.png)\n\n- 스프링 부트 버전은 2.6.2 (강좌는 2.4.1임)\n- 추가한 의존성\n    - Lombok (편의성)\n    - Spring Web\n    - Spring Security\n    - h2 Database\n    - Spring Data JPA\n    - Validation\n    \n\n![Untitled](1-5.png)\n\n- 프로젝트가 생성된 모습\n\n![Untitled](1-4.png)\n\n- Lombok을 사용하므로 Enable annotaion processing 을 체크하자.\n\n### 2. 간단한 Rest API 테스트\n\n![Untitled](1-6.png)\n\n간단한 문자열(hello)을 리턴해주는 api를 만들고 테스트해보겠습니다.\n\n- `RestController` : 컨트롤러를 JSON을 반환하는 컨트롤러로 만들어 줍니다.\n- `RequestMapping` : 요청에 대해 어떤 Controller가 처리할지를 맵핑하기 위한 어노테이션.\n- `GetMapping` : HTTP Method인 Get인 요청을 받을 수 있는 API를 만들어 준다.\n- `ResponseEntity<>` : 사용자의 HttpRequest에 대한 응답 데이터를 포함하는 클래스.\n- `ResponseEntity.ok()`: 정상적인 요청이면 메소드의 파라미터 내용을 반환한다.\n\n위 코드를 작성하고 애플리케이션을 실행하고 Postman을 통해서 해당 url로 요청을 보내겠습니다.\n\n![Untitled](1-7.png)\n\n요청을 보내면 401 HTTP 상태 코드가 반환된 것을 볼 수 있습니다.\n\n이를 해결하기 위한 Security 설정과, 기본적인 Data 설정을 하겠습니다.\n\n### Reference\n\n- [ResponseEntity 스프링 공식 문서](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html)","excerpt":"인프런 강의(Spring Boot JWT Tutorial)를 수강하며, 내용들을 기록한 페이지입니다. 배우는 것 Spring Boot를 이용한 JWT 인증, 인가 구현 Spring Security 기초 회원가입, 로그인, 권한로직 JWT 소개 (JW…","fields":{"slug":"/springboot-jwt-tutorial1/"},"frontmatter":{"date":"Jan 07, 2022","title":"SpringBoot JWT 튜토리얼 - 1장 JWT소개,프로젝트생성","tags":["SpringBoot","JWT","튜토리얼"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# asdf란? ([asdf 설치 하기](https://subicura.com/mac/dev/terminal-apps.html#asdf))\n\nasdf-vm은 각종 프로그램의 버전을 손쉽게 관리해주는 **성의 없어 보이는 이름**의 도구입니다.<br/>\n기존에 nvm, rbenv등 언어, 프로그램별로 달랐던 관리 도구를 하나로 통합해서 사용할 수 있습니다. <br/>\nhomebrew도 일부 버전 관리 기능을 제공하지만 asdf만큼 강력하지 않습니다.<br/>\nasdf를 이용하면 버전 별로 설치할 수 있는 장점이 있습니다.<br/>\n그래서 이번에는 Java 8 JDK와, Java 11 JDK 를 둘다 설치하는 것을 해보겠습니다.<br/>\n\n### 주의\n\n맥 OS 가 아닌 분들을 아쉽지만 들어온 문으로 나가주세요. \n\n## 시작\n\n```json\n❯ java --version\nopenjdk 11.0.13 2021-10-19 LTS\nOpenJDK Runtime Environment Zulu11.52+13-CA (build 11.0.13+8-LTS)\nOpenJDK 64-Bit Server VM Zulu11.52+13-CA (build 11.0.13+8-LTS, mixed mode)\n```\n\n현재 저의 자바 jdk 버전은 11입니다. 저는 jdk 8 버전의 자바 환경도 만들고 싶습니다. \n<br/>그럴려면 환경변수도 매번 지정해줘야하는 번거로움이 있습니다. \n<br/>asdf 를 이용해서 8버전과 11버전을 유연하게 돌아가며 사용할 수 있는 환경을 만들어 보겠습니다.\n\n### 이전에 이미 설치한 JAVA JDK 는 어떡합니까?\n\n만약 brew를 통해서 java를 설치하신 분이라면 brew uninstall 을 통해 jdk를 삭제하면 되고.\n\n아니면 아래 명령어를 통해 삭제하시면 됩니다.\n\n```json\n❯ sudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin\n❯ sudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefPane\n❯ sudo rm -fr ~/Library/Application\\ Support/Java\n\n❯ cd /Library/Java/JavaVirtualMachines/ \n❯ ls \n❯ sudo -rm -rf jdk-x.x.x.jdk\n```\n\n### JAVA Plugin 추가\n\n[asdf-java plugin 깃허브 링크](https://github.com/halcyon/asdf-java#java_home)\n\n- 먼저 자바 플러그인을 추가합니다\n\n```json\n❯ asdf plugin-add java https://github.com/halcyon/asdf-java.git\n```\n\n### 자바 플러그인 업데이트\n\n플러그인 목록을 최신화합니다.\n\n```json\n❯ asdf plugin update java\n```\n\n### 자바 버전 별 플러그인 보기\n\n아래 명령어를 이용하면 설치할 수 있는 자바의 버전들이 나타납니다.\n\n```json\n❯ asdf list-all java\n...\nsapmachine-jre-18-internal.0\ntemurin-17.0.0+35\ntemurin-17.0.1+12\ntemurin-jre-17.0.1+12\nzulu-8.52.0.23\nzulu-8.54.0.21\nzulu-8.56.0.23\nzulu-8.58.0.13\nzulu-11.43.1017\nzulu-11.43.1021\nzulu-11.45.27\nzulu-11.48.21\nzulu-11.50.19\nzulu-11.52.13\nzulu-13.35.1019\nzulu-13.35.1025\nzulu-13.37.21\nzulu-13.40.15\nzulu-13.42.17\nzulu-13.44.13\nzulu-15.28.1013\nzulu-15.29.15\nzulu-15.32.15\nzulu-15.34.17\nzulu-15.36.13\nzulu-16.28.11\nzulu-16.30.15\nzulu-16.30.19\nzulu-16.32.15\nzulu-17.28.13\nzulu-17.30.15\n...\n```\n\n(오라클 jdk는 설치안하는것을 추천합니다. [[JDK 라이선스 유료화]](https://zdnet.co.kr/view/?no=20181102140004)\n\n### JAVA 8, 11 버전 설치\n\n자바 8버전과 11버전의 openjdk를 설치하겠습니다.\n\n```json\n❯ asdf install java zulu-8.58.0.13\n❯ asdf install java zulu-11.52.13\n```\n\n### asdf 설치한 자바 버전 확인하기\n\n아래 명령어를 통해, 설치된 자바 버전들을 볼수있습니다.\n\n```json\n❯ asdf list java\n  zulu-11.52.13\n  zulu-8.58.0.13\n```\n\n### Global 버전으로 지정하기\n\n설치한 버전을 전역 버전으로 지정합니다. 즉 내 컴퓨터의 자바 버전을 지정한 버전으로 설정합니다.\n\n저는 8버전을 지정했습니다.\n\n```json\n❯ asdf global java zulu-8.58.0.13\n```\n\n### JAVA_HOME 설정하기\n\n[sadf java-plugin JAVA_HOME 설정](https://github.com/halcyon/asdf-java#java_home)\n\n아래 명령어를 실행하면, 자바 위치를 지정합니다. (처음 한번만 실행하면 됩니다)\n\n```json\n. ~/.asdf/plugins/java/set-java-home.zsh\n```\n\n### 자바 버전 확인하기\n\n아래 명령어를 통해 정상적으로 설치되었는지 확인합니다.\n\n```json\n❯ java -version\nopenjdk version \"1.8.0_312\"\nOpenJDK Runtime Environment (Zulu 8.58.0.13-CA-macos-aarch64) (build 1.8.0_312-b07)\nOpenJDK 64-Bit Server VM (Zulu 8.58.0.13-CA-macos-aarch64) (build 25.312-b07, mixed mode)\n```\n\n정상적으로 8버전의 jdk가 나오는 것을 볼 수 있습니다.\n\n또한 자바 환경 변수 위치까지 jdk 8로 변경된 것 을 볼 수 있습니다.\n\n```json\n❯ echo $JAVA_HOME\n/Users/seonghun/.asdf/installs/java/zulu-8.58.0.13/zulu-8.jdk/Contents/Home\n```\n\n### 현재 전역으로 설정된 버전들 보기\n\n자바 뿐만 아니라 다른 프로그램들의 버전 현황을 볼 수 있습니다. (global version)\n\n```json\n❯ asdf current\njava            zulu-8.58.0.13  /Users/seonghun/.tool-versions\nnodejs          lts-fermium     Not installed. Run \"asdf install nodejs lts-fermium\"\nyarn            1.22.17         /Users/seonghun/.tool-versions\n```\n\n### 자바 버전 변경하기\n\n아래 명령어를 통해 11버전의 자바 jdk 로 변경하겠습니다.\n\n```json\n❯ asdf global java zulu-11.52.13\n```\n\n그 후 정상적으로 버전이 변경됬는지 확인하겠습니다.\n\n```json\n❯ java --version\nopenjdk 11.0.13 2021-10-19 LTS\nOpenJDK Runtime Environment Zulu11.52+13-CA (build 11.0.13+8-LTS)\nOpenJDK 64-Bit Server VM Zulu11.52+13-CA (build 11.0.13+8-LTS, mixed mode)\n```\n\n8버전에서 11버전으로 변경된 것 을 확인할 수 있습니다.\n\n아래 명령어로 자바 환경변수 경로까지 자동으로 변경된 것 을 볼수있습니다.\n\n```json\n❯ echo $JAVA_HOME\n/Users/seonghun/.asdf/installs/java/zulu-11.52.13/zulu-11.jdk/Contents/Home\n```\n\n### 결론\n\n`asdf globale java <version>` 명령어 한 줄 만으로 자바 버전을 쉽게 변경할 수 있었습니다.\n\n(원래라면 자바 버전을 버전마다 변수로 추가해줘야함)\n\n자바 뿐만 아니라 npm, yarn 같은 패키지 매니저 또한 지원하니 검색해서 유용하게 쓰시면 되겠습니다.\n\n---\n\n[참고](https://www.wiserfirst.com/blog/install-java-with-asdf/)\n\n[subicura 님 mac asdf 설치](https://subicura.com/mac/dev/terminal-apps.html#asdf/)\n\n[맥에서 Brew로 자바 설치하기(자바 버전 바꾸기)](https://llighter.github.io/install-java-on-mac/)","excerpt":"asdf란? (asdf 설치 하기) asdf-vm은 각종 프로그램의 버전을 손쉽게 관리해주는 성의 없어 보이는 이름의 도구입니다.\n기존에 nvm, rbenv등 언어, 프로그램별로 달랐던 관리 도구를 하나로 통합해서 사용할 수 있습니다. \nhomebr…","fields":{"slug":"/asdf-java/"},"frontmatter":{"date":"Jan 05, 2022","title":"asdf 를 이용한 JAVA 버전 별 설치","tags":["JAVA","자바","asdf"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"## Spring Security란?\n\n- Spring 기반의 애플리케이션의 보안(인증과 권한, 인가 등)을 담당하는 스프링 하위 프레임워크\n- **인증**과 **권한**에 대한 부분을 **Filter** 흐름에 따라 처리\n    - Filter는 Dispatcher Servlet 으로 가기전에 적용\n    - 따라서 가장 먼저 URL 요청을 받는다.\n    - 하지만, Interceptor는 Dispatcher와 Contoller 사이에 위치한다는 점에서 적용 시기의 차이가 있다.\n\n### 인증(Authentication)과 인가(Authorization)\n\n- 인증(Authentiacation) : 해당 사용자가 본인이 맞는지를 **확인**하는 절차\n- 인가(Authorization) : 인증된 사용자가 요청한 자원에 접근 가능한지를 결정하는 절차\n\n> Authentiacation → (인증 성공 후) → Authorization\n> \n\n- Spring Security는 기본적으로 인증 절차를 거친 후, 인가 절차를 진행\n- 인가 과정에서 해당 리소스에 대한 접근 권한이 있는지를 확인하게 된다.\n- Spring Security에서는 이러한 인증과 인가를 위해 Principal을 아이디로, Credential을 비밀번호로 사용하는 **Credential 기반의 인증 방식을** 사용한다.\n    - Principal(접근 주체) : 보호받는 리소스에 접근하는 대상\n    - Credential(비밀전호) : 리소스에 접근하는 대상의 비밀번호","excerpt":"Spring Security란? Spring 기반의 애플리케이션의 보안(인증과 권한, 인가 등)을 담당하는 스프링 하위 프레임워크 인증과 권한에 대한 부분을 Filter 흐름에 따라 처리 Filter는 Dispatcher Servlet 으로 가기전에…","fields":{"slug":"/spring-security-1/"},"frontmatter":{"date":"Jan 04, 2022","title":"SpringSecurity 란?","tags":["Spring Security"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n개인적으로 참고할려고 기록하는 글입니다.\n\n## MSA 구성요소 및 패턴의 유형\n\n- 인프라 구성요소 : 마이크로서비스를 지탱하는 하부구조 인프라를 구축하는데 필요한 구성요소\n- 플랫폼 패턴 : 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패턴\n- 애플리케이션 패턴 : 마이크로서비스 애플리케이션을 구성하는데 필요한 패턴\n\n## 서비스 유형별 대표적인 클라우드 서비스\n\n- `Iaas(Infrastructure as a Service)` :\n  가상 머신, 스토리지, 네트워크 같은 인프라를 필요한 만큼 적시에 제공하는 서비스\n  (예시 : AWS EC2, GCP Compute Engine, Azure VM)\n\n- `CaaS(Container as a Service)` :\n  컨테이너 기반 가상화를 사용해 컨테이너를 업로드, 구성, 실행, 확장, 중지할 수 있는 서비스\n  (예시 : Google Kubernetes Engine, AWS ECS)\n\n- `Paas(Platform as a Service)` : 애플리케이션을 즉시 개발, 실행, 관리할 수 있는 플랫폼 환경 서비스\n  (예시 : Azure Web App, Google App Engine, Heroku, AWS Elastic Beanstalk)\n\n## 개발 지원 환경 DevOps\n\n- `DevOps` : 마이크로서비스를 빌드하고 테스트한 뒤 배포할 수 있게 도와주는 개발 지원 환경\n\n- `CI/CD` - 자동화된 빌드나 배포작업,\n\n  - `CI`는 `지속적 통합(Continuous Integration)` 자동으로 통합 및 테스트하고 그 결과를 기록하는 활동\n  - `CD`는 `지속적 제공(Continuous Delivery)` 및 `지속적 배포(Continouss Deployment)` 실행환경에 내보내는 활동\n  - `지속적 제공`은 빌드된 소스코드의 실행 파일을 실행환경에 반영하기 위해 승인 및 배포 담당자의 허가를 받아야하고\n    배포도 수동으로 처리한다.\n  - `지속적 배포`은 소스코드 저장소(Github)에서 빌드한 소스코드의 실행 파일을 실행 환경 까지 자동으로 배포하는 방식\n    모든 영역을 자동화하는 것에 해당함.\n\n- `Infrastructure as a Code` - 인프라 구성을 마치 프로그래밍하는 것 처럼 처리하고 소수의 인원으로 컨테이너 배포 처리하는 과정\n  (배포 파이프라인 절차를 코드로 완벽히 자동화)\n\n## MSA 주요 아키텍처 패턴\n\n- Spring Cloud + DevOps\n  - Spring Cloud : Spring Boot + Netflix OSS\n\n## 참고한 자료\n\n- [도메인 주도 설계로 시작하는 마이크로서비스 개발](http://www.yes24.com/Product/Goods/98880996)","excerpt":"개인적으로 참고할려고 기록하는 글입니다. MSA 구성요소 및 패턴의 유형 인프라 구성요소 : 마이크로서비스를 지탱하는 하부구조 인프라를 구축하는데 필요한 구성요소 플랫폼 패턴 : 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패…","fields":{"slug":"/msa-related-term/"},"frontmatter":{"date":"Sep 28, 2021","title":"마이크로서비스 아키텍처(MSA) 관련 용어 정리","tags":["MSA","마이크로서비스 아키텍쳐","정리"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n처음에는 Jekyll로 블로그를 만들었는데 생각보다 마음에 안들어서, 검색하다보니 Gatsby를 발견했다.\nGatsby는 `React` 프레임워크를 기반으로 만들었는데 React를 전에 한번 입문해봐서 이걸로 선택했다.\n<br>\n<br>\n처음에는 `npm`으로 node module를 설치해서 환경을 구성했는데. 후반에 가니깐 한번 꼬이니깐 계속 꼬여서\nnpm을 재설치하고 시간을 많이 잡아 먹었다. 그래서 `yarn`으로 다시 패키지 설치하고 하니 잘되더라.\n<br>\n<br>\n# 1. Gatsby 설치\n\n## Gatsby-cli 설치\n패키지 매니저를 통해서 `gatsby-cli`를 설치한다.\n``` sh\n# npm\nnpm install -g gatsby-cli\n```\n```sh\n# yarn\nyarn add gatsby-cli\n```\n\n## 테마 설치\n```sh\ngatsby new [디렉터리 이름] [테마 깃허브 주소]\n```\n디렉터리에 다운받은 테마가 위치된다.\n```sh\ncd [디렉터리 이름]\nyarn start\n```\n\n그후 [localhost:8000](localhost:8000) 를 접속해서 설치한 테마를 맛본다.\n\n# 2. 나만의 블로그로 꾸미기\n## 포스트 위치\n다음 위치에서 블로그 포스팅을 추가할 수 있다.\n\n- `content/blog` : 포스트 파일 위치\n- `content/__about` : 프로필 파일 위치\n\n<br>\n\n포스트 파일은 `.markdown` 또는 `.md`을 사용한다.\n<br>\n\n## 메타데이터\n`gatsby-config.js` 파일이나 `gatsby-meta-config.js`파일에서 \n<br>\n블로그를 설정하는\n여러 요소를 수정할 수 있다.\n원하는 설정으로 수정하면된다.\n\n그 외의 설정은 \n`gatsby-browser.js`, `gatsby-node.js`을 참고\n\n## CSS 파일\n`src/styles` 위치에서 CSS 속성들을 수정할 수 있다.\n\n<br>\n직접 설정을 다하면 글을 한번 작성해봐서 깃허브 저장소나 자신만의 서버에서 배포하면된다.\n\n# 3. SEO 적용\nSEO는 `search engine optimization`로 검색 엔진 최적화, 구글이나 네이버에서 우리 블로그를 찾기 쉽도록 사이트를 개선하는 프로세스이다.\n\n## sitemap.xml 생성\n검색엔진에 검색이 잘 되게 할려면 웹 크롤러가 우리 사이트를 찾아와 크롤링을 하는데, 우리는 이정표를 만들어줘야한다.\n`sitemap.xml`이 이정표 역활을 한다.\n<br>\ngatsby는 `sitemap.xml`을 자동 생성해주는 플러그인이 있다. 추가하자\n<br>\n<br>\n`gastby-config.js`\n```js\n    plugins: [\n        ...\n        'gatsby-plugin-sitemap',\n    ]\n```\nplugins에 추가하면 build 될 때 마다 파일을 생성해준다.\n\n<br>\n그 후 플러그인을 설치하고, gatsby를 실행 한다.\n\n```sh\nyarn add gatsby-plugin-sitemap\ngatsby develop\n```\n\n[http://localhost:8000/sitemap.xml](http://localhost:8000/sitemap.xml)에 접속\n\n```xml\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\" xmlns:mobile=\"http://www.google.com/schemas/sitemap-mobile/1.0\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\">\n    <url>\n    ...\n    </url>\n</urlset>\n```\n위와 같은 xml 형식의 문서가 나오면 성공.\n\n## rss.xml 생성\nrss는 사이트를 방문하지 않아도 그 사이트의 새로운 글이 올라오면 알람을 준다고 생각하면된다.\n그리고 rss를 등록하는것도 검색엔진최적화 작업에 해당된다.\n\n```sh\nyarn add gatsby-plugin-feed\n```\n`sitemap`과 마찬가지로 build 할때마다 새로운 파일을 생성해야 하니 plugins에 추가하자.\n\n`gastby-config.js`\n```js\n    plugins: [\n        ...\n        'gatsby-plugin-feed',\n    ]\n```\n`rss.xml` 이 제대로 생성됬는지 확인하자\n```sh\ngatsby develop\n```\n그 후 [http://localhost:8000/rss.xml](http://localhost:8000/rss.xml)에 접속\n<br>\n`rss.xml` 페이지가 제대로 나온다면 성공.\n\n## robots.txt 생성\n`robots.txt`도 웹 크롤러가 사이트에 접속하면 찾는 파일이므로 만들어준다.\n\n```sh\nyarn add gatsby-plugin-robots-txt\n```\n`gastby-config.js`\n\n```js\nplugins: [\n\t...\n\t{\n      resolve: 'gatsby-plugin-robots-txt',\n      options: {\n        host: 웹사이트경로,\n        sitemap: 웹사이트경로/sitemap.xml',\n        policy: [{\n          userAgent: '*',\n          allow: '/'\n        }]\n      }\n    },\n\t...\n]\n```\n그리고 빌드해서 확인.\n\n```sh\ngatsby develop\n```\n그 후 [http://localhost:8000/robots.txt](http://localhost:8000/robots.txt)에 접속해\n`robots.txt`가 생성됬는지 확인한다.\n\n## 구글 서치 콘솔(GSC) 등록\n[구글등록](https://search.google.com/search-console/about)에서 시작하기를 통해 등록한다.\n우측에 URL 접두어를 선택하고 인증용 html 파일을 다운로드한다.\n다운받은 html 파일은 프로젝트 경로에 복사하고 `package.json`에서 build 스크립트를 작성한다.\n<br>\n`package.json`\n\n```json\n  \"scripts\": {\n        ...\n        \"copy\" : \"cp content/google인증용파일.html public/\",\n        \"build\": \"gatsby build && npm run copy\",\n        ...\n  }\n```\n빌드시 `npm run copy`를 통해 인증 html 파일을 public 경로로 복사해 줄 것이다.\n\n```\nyarn build\ngatsby serve\n```\n를 통해 \"http://localhost:9000/google인증파일.html\" 접속해서 잘 뜨는지 확인한다.\n그리고 sitemaps 메뉴내에 빈칸에 `sitemap.xml` 입력하고 제출한다.\n\n그러면 구글검색엔진에 등록되기까진 몇시간정도 걸리므로 기다리고 검색창에 `site: 블로그주소` 를 입력해서 확인하자.\n\n\n## 네이버 검색 노출\n\n네이버 검색도 구글에 하던것처럼 하면된다.\nhttps://searchadvisor.naver.com/console/board 접속해서 사이트를 등록한다.\n- 좌측 사이드바 메뉴에서 요청 - 사이트맵 제출에서 sitemap.xml의 경로를 입력한다.\n- 요청 - RSS 제출에서도 마찬가지로 경로를 입력한다.\n- 검증 - robots.txt에서 robots.txt 검증 및 수집요청을 한다.\n- 설정 - 수집 주기 설정을 빠르게를 체크한다.\n모든 등록이 끝났으면 몇시간뒤에 검색창에서 `site: 블로그주소`를 입력해서 등록됬는지 확인한다.\n\n## 다음 검색 노출\n다음은 다른 검색엔진보다 매우 간단해서.\nhttps://register.search.daum.net/index.daum에 접속해서 블로그를 등록만하면 끝이다.\n\n\n# 끝으로\n이렇게 간단하게 겟츠비를 통해서 블로그를 만들고 SEO 적용까지 해봤다.\n생략된 부분도 많지만 충분히 참고할 수 있을 것이다.\nReact를 잘 사용하거나 앞으로 사용해야하는 개발자가 블로그를 만들게 된다면\nGatsby로 만들어보는 것을 추천한다. 테마로 만들어도 되지만 자신이 직접 react로 만들어도 좋을것이다.\n<br>\n만약에 블로그를 수정하다가 `npm` 관련 오류가 발생한다면, yarn으로 전환해서 구축하거나,\nnpm 패키지를 재설치 해보자.\n\n\n","excerpt":"처음에는 Jekyll로 블로그를 만들었는데 생각보다 마음에 안들어서, 검색하다보니 Gatsby를 발견했다.\nGatsby는  프레임워크를 기반으로 만들었는데 React를 전에 한번 입문해봐서 이걸로 선택했다.\n\n\n처음에는 으로 node module를 …","fields":{"slug":"/gatsby-blog-start/"},"frontmatter":{"date":"Sep 28, 2021","title":"Gatsby로 블로그를 만들기","tags":["Gatsby","Blog"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n#application.properties\n\n스프링 애플리케이션은 다음 리소스가 주어진 순서대로 고려된다.\n\n1. 명령행 인수\n2. 패키징된 애플리케이션 외부의 `application.properties`\n3. 패키징된 애플리케이션 내부의 `application.properties`\n\napplication-{profile}.properties는 프로필에 관련되지 않은 파일 보다 우선된다.\n\n1. 명령행 인수\n2. 패키징된 애플리케이션 외부의 `application-{profile}.properties`\n3. 패키징된 애플리케이션 외부의 `application.properties`\n4. 패키징된 애플리케이션 내부의 `application-{profile}.properties`\n5. 패키징된 애플리케이션 내부의 `application.properties`\n\n##application.properties 에서 속성 값 사용하기\n속성 외부화를 위해 우리가 만든 application.properties를 사용할려면 `@Value` 어노테이션을 사용해야한다.\n`@Value` 어노테이션은 스프링이 속성을 찾고 해당 속성의 값을 사용하도록 지시한다.\n\n```java\npublic 리턴타입 메소드(@Value(\"${hi}\") int hi) {\n  ...\n}\n```\n\n스프링은 hi라는 이름을 가진 속성을 감지하고 그 값을 사용한다.\n\n또한 `:`을 사용해 기본값을 지정할 수 있다.\n\n```java\npublic 리턴타입 메소드(@Value(\"${hi:10}\") int hi) {\n  ...\n}\n```\n\n만약 `:` 기본값을 지정하면 값을 찾지 못했을 때 10을 기본값으로 사용한다.\n기본값을 정의하지 않고, 해당 속성이 없을 때 `IllegalArgumentException`이 발생한다.\n\n##프로필을 사용한 속성 재정의\n스프링 부트는 프로필을 사용해 추가 구성 파일을 불러와 기존의 application.properties를 전부 대체 또는 일부를 재정의할 수 있다.\n`application-{profile}.properties`를 만들면 된다.\n만약에 `application.properties`에 `hi` 값이 있고, `application-hi.properties`에 `hi`라는 값이 있으면\n`application-hi.properties`의 속성 우선순위가 높기 때문에 대체된다.\n\n##다른 속성 파일로부터 속성 불러오기\n내가 사용하고 싶은 속성 파일을 불러오고자 하면은, `@SpringBootApplication` 어노테이션이 붙은 클래스에\n`@PropertySource` 어노테이션을 추가해 사용할 수 있다.\n\n```java\n@PropertySource(\"classpath:임의의속성파일.properties\")\n@SpringBootApplication\npublic class MySpringApp {\n...\n}\n```\n\n`@PropertySource` 어노테이션은 스프링부트가 시작할 때 추가 속성 파일을 불러와준다.\n해당 어노테이션 대신 밑에 표의 매개변수를 사용하면 스프링 부트가 추가 속성 파일을 불러온다.\n\n| 매개변수                          |                         설명 |\n| :-------------------------------- | ---------------------------: |\n| spring.config.name                |             불러올 파일 목록 |\n| spring.config.location            |             속성 파일의 위치 |\n| spring.config.additional-location | 속성 파일을 불러올 추가 위치 |\n\n위 매개변수를 사용하면, application.properties는 불러오지 않는다.\n모두 검색하는 방법으로는 `--spring.config.name=application,불러올속성파일`을 사용한다.","excerpt":"application.properties 스프링 애플리케이션은 다음 리소스가 주어진 순서대로 고려된다. 명령행 인수 패키징된 애플리케이션 외부의  패키징된 애플리케이션 내부의  application-{profile}.properties는 프로필에 관…","fields":{"slug":"/springboot-application-properties-extern/"},"frontmatter":{"date":"Sep 27, 2021","title":"[SpringBoot] 속성 외부화","tags":["SpringBoot","속성","Properties"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}