{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"# 1. 회원가입 API 작성\n\n## SecurityUtil 클래스\n\n간단한 유틸리티 메소드를 만들기 위해 `SecurityUtil` 클래스를 util 패키지에 생성하겠습니다.\n\n```java\npublic class SecurityUtil {\n\n   private static final Logger logger = LoggerFactory.getLogger(SecurityUtil.class);\n\n   private SecurityUtil() {\n   }\n\n   public static Optional<String> getCurrentUsername() {\n      final Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n\n      if (authentication == null) {\n         logger.debug(\"Security Context에 인증 정보가 없습니다.\");\n         return Optional.empty();\n      }\n\n      String username = null;\n      if (authentication.getPrincipal() instanceof UserDetails) {\n         UserDetails springSecurityUser = (UserDetails) authentication.getPrincipal();\n         username = springSecurityUser.getUsername();\n      } else if (authentication.getPrincipal() instanceof String) {\n         username = (String) authentication.getPrincipal();\n      }\n\n      return Optional.ofNullable(username);\n   }\n```\n\n`getCurrentUsername` 메소드의 역활은 SecurityContext의 Authentication 객체를 이용해 `username`을 리턴해주는 간단한 유틸성 메소드입니다. \n\n`SecurityContext`에 Authenticaion 객체가 저장되는 시점은 JwtFilter의 `doFilter`메소드에서 Request가 들어올때 SecurityContext에 Authenticaion 객체를 저장해서 사용하게 됩니다.\n\n## UserService 클래스\n\n회원가입, 유저 정보 조회등의 메소드를 만들기 위해 UserService 클래스를 생성하겠습니다.\n\n```java\n@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    private final PasswordEncoder passwordEncoder;\n\n    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {\n        this.userRepository = userRepository;\n        this.passwordEncoder = passwordEncoder;\n    }\n\n@Transactional\n    public User signup(UserDto userDto) {\n        if (userRepository.findOneWithAuthoritiesByUsername(userDto.getUsername()).orElse(null) != null) {\n            throw new RuntimeException(\"이미 가입되어 있는 유저입니다.\");\n        }\n\n        Authority authority = Authority.builder()\n                .authorityName(\"ROLE_USER\")\n                .build();\n\n        User user = User.builder()\n                .username(userDto.getUsername())\n                .password(passwordEncoder.encode(userDto.getPassword()))\n                .nickname(userDto.getNickname())\n                .authorities(Collections.singleton(authority))\n                .activated(true)\n                .build();\n\n        return userRepository.save(user);\n    }\n\n    @Transactional(readOnly = true)\n    public Optional<User> getUserWithAuthorities(String username) {\n        return userRepository.findOneWithAuthoritiesByUsername(username);\n    }\n\n    @Transactional(readOnly = true)\n    public Optional<User> getMyUserWithAuthorities() {\n        return SecurityUtil.getCurrentUsername().flatMap(userRepository::findOneWithAuthoritiesByUsername);\n    }\n}\n```\n\nUserService 클래스는 `UserRepository`, `PasswordEncoder`를 주입받습니다.\n\n`singup` 메소드는 username이 DB에 존재하지 않으면 Authority와 User 정보를 생성해서 UserRepository의 `save`메소드를 통해 DB에 정보를 저장합니다. \n\n여기서 **중요한 점**은 `singup` 메소드를 통해 가입한 회원은 USER ROLE을 가지고 있고 `data.sql` 에서 자동 생성되는 admin 계정은 USER, ADMIN ROLE을 가지고 있습니다 이 차이를 통해 권한검증 부분을 테스트 하겠습니다.\n\n그리고 유저 권한정보를 가져오는 메소드가 2개 있습니다.\n\n`getUserWithAuthorities`는 username을 기준으로 정보를 가져오고\n\n`getMyUserWithAuthorities`는 SecurityContext에 저장된 username의 정보만 가져옵니다.\n\n이 두가지 메소드의 허용권한을 다르게 해서 권한검증에 대한 부분을 테스트하겠습니다.\n\n# 2. 권한 검증\n\n## UserController 클래스\n\n`UserService`의 메소드들을 호출할 `UserController` 클래스를 생성하겠습니다.\n\n```java\n@RestController\n@RequestMapping(\"/api\")\npublic class UserController {\n    private final UserService userService;\n\n    public UserController(UserService userService) {\n        this.userService = userService;\n    }\n\n    @PostMapping(\"/signup\")\n    public ResponseEntity<User> signup(@Valid @RequestBody UserDto userDto) {\n        return ResponseEntity.ok(userService.signup(userDto));\n    }\n\n    @GetMapping(\"/user\")\n    @PreAuthorize(\"hasAnyRole('USER','ADMIN')\")\n    public ResponseEntity<User> getMyUserInfo(HttpServletRequest request) {\n        return ResponseEntity.ok(userService.getMyUserWithAuthorities().get());\n    }\n\n    @GetMapping(\"/user/{username}\")\n    @PreAuthorize(\"hasAnyRole('ADMIN')\")\n    public ResponseEntity<User> getUserInfo(@PathVariable String username) {\n        return ResponseEntity.ok(userService.getUserWithAuthorities(username).get());\n    }\n}\n```\n\n- `@PreAuthorize`\n    - 해당 메서드가 호출되기 이전에 권한을 검사한다\n- `hasAnyRole([role1, role2])`\n    - 현재 사용자의 권한이 파라미터의 권한 중 일치하는 것이 있는 경우 `true` 를 리턴\n\n`sinup` 메소드는 UserDto를 매개변수로 받아서 UserService의 `singup` 메소드를 호출합니다.\n\n`getMyUserInfo` 메소드는 `@PreAuthorize`를 통해서 USER, ADMIN 두가지 권한 모두 허용했고\n\n`getUserInfo` 메소드는 ADMIN 권한만 호출할 수 있도록 설정했습니다 그리고 `UserService`에서 만들었던 username 매개변수를 기준으로 유저 정보와 권한 정보를 리턴하는 API가 되겠습니다. \n\n# 3. Response 시 DTO를 통해서만 받기\n\n## 기존 문제점\n\n추가적으로 지금까지 로직을 보시면 사용자 요청에 대해 응답을 Entity 그대로 전달하기 때문에 문제가있습니다.  문제점을 보기위해 Entity를 통해 반환을 하게 되면 어떤 결과를 나오는지 보겠습니다.\n\n- Response - `POST` /api/signup\n\n```json\n{\n    \"userId\": 3,\n    \"username\": \"hoon\",\n    \"password\": \"$2a$10$PZhLrJzS9YQX1.M5.ezMhu/VFAbtSiYLU.ExF3qzlBrrk7bHPyzdm\",\n    \"nickname\": \"nick\",\n    \"activated\": true,\n    \"authorities\": [\n        {\n            \"authorityName\": \"ROLE_USER\"\n        }\n    ]\n}\n```\n\n해당 응답 결과처럼, 보시면은 중요한 정보들이 그대로 반환이 됩니다 그 이유는 `UserService`의 회원가입 로직을 처리하는 메소드가 User Entity 그대로 반환해주기 때문에 사용자 측에서는 해당 결과를 받게됩니다.\n\n보안적인 측면에서도 안좋은 방식이므로 DTO를 통해 응답하도록 코드를 수정하겠습니다.\n\n## 해결법\n\n### AuthorityDto 클래스 생성\n\n권한정보에 대한 DTO 클래스를 작성하겠습니다.\n\n```java\n@Getter\n@Setter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class AuthorityDto {\n    private String authorityName;\n}\n```\n\n### UserDto 클래스 수정\n\n아래와 같이 권한 정보에 대한 `authorityDtoSet` 필드를 추가하고 `from` 메소드를 추가합니다.\n\n```java\nprivate Set<AuthorityDto> authorityDtoSet;\n\n    public static UserDto from(User user) {\n        if(user == null) return null;\n\n        return UserDto.builder()\n                .username(user.getUsername())\n                .nickname(user.getNickname())\n                .authorityDtoSet(user.getAuthorities().stream()\n                        .map(authority -> AuthorityDto.builder().authorityName(authority.getAuthorityName()).build())\n                        .collect(Collectors.toSet()))\n                .build();\n    }\n```\n\n`from` 메소드는 `User` 객체를 매개변수로 받아서 해당 객체가 `null`이 아니면, 해당 객체를 `UserDto`로 생성해서 반환합니다.\n\n### UserService 클래스 수정\n\n`User`로 반환하던 이전 메소드들을 `UserDto`로 반환하도록 수정하겠습니다. (굵은 글씨를 봐주세요)\n\n```java\n@Transactional\n    public **UserDto** signup(UserDto userDto) {\n        if (userRepository.findOneWithAuthoritiesByUsername(userDto.getUsername()).orElse(null) != null) {\n            throw new RuntimeException(\"이미 가입되어 있는 유저입니다.\");\n        }\n\n        Authority authority = Authority.builder()\n                .authorityName(\"ROLE_USER\")\n                .build();\n\n        User user = User.builder()\n                .username(userDto.getUsername())\n                .password(passwordEncoder.encode(userDto.getPassword()))\n                .nickname(userDto.getNickname())\n                .authorities(Collections.singleton(authority))\n                .activated(true)\n                .build();\n\n        return **UserDto.from**(userRepository.save(user));\n    }\n\n    @Transactional(readOnly = true)\n    public **UserDto** getUserWithAuthorities(String username) {\n        return **UserDto.from**(userRepository.findOneWithAuthoritiesByUsername(username)**.orElse(null))**;\n    }\n\n    @Transactional(readOnly = true)\n    public **UserDto** getMyUserWithAuthorities() {\n        return **UserDto.from**(SecurityUtil.getCurrentUsername().flatMap(userRepository::findOneWithAuthoritiesByUsername)**.orElse(null))**;\n    }\n```\n\n회원가입 로직을 처리하는 `signup` 메소드는 기존 소스 그대로에서 `UserDto.from` 을 통해 `User`를 Dto로 생성해서 반환합니다.\n\n나머지 두개의 권한 정보을 반환하는 메소드도 `UserDto`로 반환하도록 수정합니다.\n\n기존에는 `Optional`을 통해서 `null` 예외처리를 해줬지만, 이젠 `null` 값이 들어오면 해당 값 그대로 리턴합니다.\n\n### UserController 클래스 수정\n\n요청에 대해 `User`로 반환하던 이전 메소드들을 `UserDto`로 반환하도록 수정하겠습니다.\n\n```java\n@PostMapping(\"/signup\")\n    public ResponseEntity<**UserDto**> signup(@Valid @RequestBody UserDto userDto) {\n        return ResponseEntity.ok(userService.signup(userDto));\n    }\n\n    @GetMapping(\"/user\")\n    @PreAuthorize(\"hasAnyRole('USER','ADMIN')\")\n    public ResponseEntity<**UserDto**> getMyUserInfo(HttpServletRequest request) {\n        return ResponseEntity.ok(userService.getMyUserWithAuthorities());\n    }\n\n    @GetMapping(\"/user/{username}\")\n    @PreAuthorize(\"hasAnyRole('ADMIN')\")\n    public ResponseEntity<**UserDto**> getUserInfo(@PathVariable String username) {\n        return ResponseEntity.ok(userService.getUserWithAuthorities(username));\n    }\n```\n\n기존과 비슷하게 반환하는 객체를 `UserDto`로 변경해줍니다.\n\nAPI 요청에 대해 `Entity`을 반환하는것이 아닌 `Dto`를 반환하는 코드로 변경을 완료했습니다.\n\n# 4. 회원가입 API 테스트\n\n이제 우리가 만든 3개의 API를 Postman, H2 Console를 이용해 테스트해보겠습니다.\n\n## 회원가입 요청\n\nURL : [http://localhost:8080/api/signup](http://localhost:8080/api/signup) 경로로 `POST` 요청을 보냅니다.\n\n![Untitled](5-1.png)\n\n- Response\n    \n    ```json\n    {\n        \"username\": \"hoon\",\n        \"nickname\": \"nick\",\n        \"authorityDtoSet\": [\n            {\n                \"authorityName\": \"ROLE_USER\"\n            }\n        ]\n    }\n    ```\n    \n\n회원가입 API에 대한 응답이 정상적으로 반환됬습니다 이제 가입된 유저정보를 H2 Console 에서 확인해보겠습니다.\n\n### H2 Console\n\n<img src=\"5-2.png\" width=\"300\" height=\"500\"/>\n\n추가한 유저 정보가 잘 등록된것을 볼수있습니다.\n\n이제 권한이 다른 두 계정(admin, uesr)을 가지고 두 개의 API를 테스트해보겠습니다.\n\n## 권한 API 테스트\n\n먼저 ADMIN 권한만 허용했던 API를 테스트하겠습니다.\n\nURL : [http://localhost:8080/api/user/hoon](http://localhost:8080/api/user/hoon) 경로로 GET 요청을 합니다.\n\n- Response - `GET` /api/user/hoon\n    \n    ![Untitled](5-3.png)\n    \n\n401 상태가 반환된것을 볼수있습니다.\n\n### JWT Token 가져오기\n\nADMIN 계정을 로그인해서 token을 가져오겠습니다,\n\nURL : [http://localhost:8080/api/authenticate](http://localhost:8080/api/authenticate) 경로에 POST 요청을 보냅니다.\n\n- Response - `POST` /api/authenticate\n    \n    ```json\n    {\n        \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImF1dGgiOiJST0xFX0FETUlOLFJPTEVfVVNFUiIsImV4cCI6MTY0MjE2NTU3N30.UyNbN-cX82pIRHOMKWTjnDSTLX-TWzER3otxNaKKTxeB9egSL2gp8FMzr5wznIFRXEyBdU-1cFMcKnQerBjiGg\"\n    }\n    ```\n    \n\n그리고 해당 어드민 유저의 토큰을 HTTP Headers에 `Authorization : Bearer {jwt_token}` 형식으로 담고 다시 권한 API 경로로 GET 요청을 보냅니다.\n\n### ADMIN 권한 테스트\n\n- Response - `GET` /api/user/hoon\n    \n    ```json\n    {\n        \"username\": \"hoon\",\n        \"nickname\": \"nick\",\n        \"authorityDtoSet\": [\n            {\n                \"authorityName\": \"ROLE_USER\"\n            }\n        ]\n    }\n    ```\n    \n\n/api/user/hoon 경로는 `ROLE_ADMIN` 권한을 가진 유저만 접근할 수 있는데. 정상적으로 응답이 된것을 확인할수있습니다.\n\n### USER 권한 테스트\n\n이번에는 hoon 계정의 토큰으로 이 API를 재호출 해보도록 하겠습니다.\n\n기존에 로그인 API를 hoon 계정으로 요청하고, 토큰을 발급받습니다.\n\n- Response - `POST` /api/authenticate\n    \n    ```json\n    {\n        \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJob29uIiwiYXV0aCI6IlJPTEVfVVNFUiIsImV4cCI6MTY0MjE2NjA1N30.UMN19s9OGrX10qcO6tgET91rggoatwtfutr6L2iuL4da67vF7vR_4D1zXOKb4_0pCVtamREhGsDm_Y-iMImBPg\"\n    }\n    ```\n    \n\nhoon 계정으로 POST 요청을 했고 해당 토큰을 이용해서 다시 API 를 호출하겠습니다.\n\n- Response - `GET` /api/user/hoon\n    \n    ```json\n    {\n        \"timestamp\": \"2022-01-13T13:15:29.386+00:00\",\n        \"status\": 403,\n        \"error\": \"Forbidden\",\n        \"path\": \"/api/user/hoon\"\n    }\n    ```\n    \n\nhoon 계정의 토큰으로 요청을 해보면 `403 Foribidden` 에러가 반환된 것을 볼수있습니다.\n\n해당 403 Forbidden 에러는 저희가 작성한 `JwtAccessDeniedHandler`에 의해 발생됬습니다.\n\n이번에는 USER권한을 허용해줬던 API를 hoon 계정의 토큰으로 호출해보겠습니다.\n\n- Response - `GET` /api/user\n    \n    ```json\n    {\n        \"username\": \"hoon\",\n        \"nickname\": \"nick\",\n        \"authorityDtoSet\": [\n            {\n                \"authorityName\": \"ROLE_USER\"\n            }\n        ]\n    }\n    ```\n    \n\nhoon 계정으로 발급받은 토큰으로 이 API 는 잘 호출되는 것을 볼수있습니다.\n\n이제 해당 강의에서 준비한 JWT Tutorial의 모든 부분이 완료됬습니다. 읽어주셔서 감사합니다😊\n\n# Reference\n\n[https://gaemi606.tistory.com/entry/Spring-Boot-Spring-Security-PreAuthorize사용하기](https://gaemi606.tistory.com/entry/Spring-Boot-Spring-Security-PreAuthorize%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)\n\n[https://steemit.com/kr-dev/@igna84/spring-security-preauthorize-postauthorize](https://steemit.com/kr-dev/@igna84/spring-security-preauthorize-postauthorize)","excerpt":"1. 회원가입 API 작성 SecurityUtil 클래스 간단한 유틸리티 메소드를 만들기 위해  클래스를 util 패키지에 생성하겠습니다.  메소드의 역활은 SecurityContext의 Authentication 객체를 이용해 을 리턴해주는 간단한…","fields":{"slug":"/springboot-jwt-tutorial5/"},"frontmatter":{"date":"Jan 14, 2022","title":"SpringBoot JWT 튜토리얼 - 5장 회원가입, 권한검증 [최종]","tags":["SpringBoot","JWT","튜토리얼"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# 1. DTO 클래스 생성\n\n## LoginDto 클래스\n\n외부와의 통신에 사용할 DTO 패키지 및 클래스를 생성합니다.\n\n```java\n@Getter\n@Setter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class LoginDto {\n\n    @NotNull\n    @Size(min = 3, max = 50)\n    private String username;\n\n    @NotNull\n    @Size(min = 3, max = 100)\n    private String password;\n}\n```\n\nLombok 어노테이션(Get, Set 등)이 추가되었고 @Valid 관련 어노테이션을 추가했습니다.\n\n로그인 할 이용자의 아이디, 비밀번호를 담을 username, password 필드를 가집니다.\n\n## TokenDto 클래스\n\nToken 정보를 Response 할때 사용할 TokenDto를 만들겠습니다.\n\n```java\n@Getter\n@Setter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class TokenDto {\n\n    private String token;\n}\n```\n\n## UserDto 클래스\n\n회원가입시에 사용할 UserDto 클래스도 미리 만들어주겠습니다.\n\n```java\n@Getter\n@Setter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class UserDto {\n\n    @NotNull\n    @Size(min = 3, max = 50)\n    private String username;\n\n    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)\n    @NotNull\n    @Size(min = 3, max = 100)\n    private String password;\n\n    @NotNull\n    @Size(min = 3, max = 50)\n    private String nickname;\n}\n```\n\n# 2. Repository 관련 코드 작성\n\n이제 Repository들을 만들어주기 위해 repository 패키지를 생성합니다.\n\n## UserRepository 인터페이스\n\n이전에 만들었던 User 엔티티에 매핑되는 UserRepository 인터페이스를 만들겠습니다.\n\n```java\npublic interface UserRepository extends JpaRepository<User, Long> {\n    @EntityGraph(attributePaths = \"authorities\")\n    Optional<User> findOneWithAuthoritiesByUsername(String username);\n}\n```\n\n- `EntityGraph` : 쿼리가 수행될때 Lazy 조회가 아니고 Eager조회로 authorities 정보를 같이가져옵니다.\n    - Lazy, Eager : 지연로딩(lazy), 즉시로딩(eager) 연관관계의 데이터를 어떻게 가져올지 (fetch)\n\n`JpaRepository`를 `extends` 하면 `findAll`, `save` 등의 메소드를 기본적으로 사용할 수 있습니다.\n\n`findOneWithAuthoritiesByUsername` 메소드는 username을 기준으로 User 정보를 가져올때 권한 정보도 같이 가져오게됩니다.\n\n# 3. 로그인 API, 관련 로직 생성\n\n## CustomUserDetailsService 클래스\n\nSpring Security에서 중요한 부분중 하나인 UserDetailsService를 구현한 CustomUserDetailsService 클래스를 생성하겠습니다. \n\n먼저 service 패키지를 만들어고 해당 패키지에 클래스를 생성합니다.\n\n```java\n@Component(\"userDetailsService\")\npublic class CustomUserDetailsService implements UserDetailsService {\n    private final UserRepository userRepository;\n\n    public CustomUserDetailsService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    @Override\n    @Transactional\n    public UserDetails loadUserByUsername(final String username) {\n        return userRepository.findOneWithAuthoritiesByUsername(username)\n                .map(user -> createUser(username, user))\n                .orElseThrow(() -> new UsernameNotFoundException(username + \" -> 데이터베이스에서 찾을 수 없습니다.\"));\n    }\n\n    private org.springframework.security.core.userdetails.User createUser(String username, User user) {\n        if (!user.isActivated()) {\n            throw new RuntimeException(username + \" -> 활성화되어 있지 않습니다.\");\n        }\n        List<GrantedAuthority> grantedAuthorities = user.getAuthorities().stream()\n                .map(authority -> new SimpleGrantedAuthority(authority.getAuthorityName()))\n                .collect(Collectors.toList());\n        return new org.springframework.security.core.userdetails.User(user.getUsername(),\n                user.getPassword(),\n                grantedAuthorities);\n    }\n}\n```\n\n`UserDetailsService`를 `implements`하고 `UserRepository`를 주입받습니다. `loadUserByUsername` 메소드를 오버라이드해서 로그인시에 DB에서 유저정보와 권한정보를 가져오게됩니다.\n\n해당 정보를 기반으로 해서 `userdetails.user` 객체를 생성해서 리턴합니다.\n\n## AuthController 클래스\n\n로그인 API를 추가하기 위해서 AuthController 클래스를 만들겠습니다.\n\n```java\n@RestController\n@RequestMapping(\"/api\")\npublic class AuthController {\n    private final TokenProvider tokenProvider;\n    private final AuthenticationManagerBuilder authenticationManagerBuilder;\n\n    public AuthController(TokenProvider tokenProvider, AuthenticationManagerBuilder authenticationManagerBuilder) {\n        this.tokenProvider = tokenProvider;\n        this.authenticationManagerBuilder = authenticationManagerBuilder;\n    }\n\n    @PostMapping(\"/authenticate\")\n    public ResponseEntity<TokenDto> authorize(@Valid @RequestBody LoginDto loginDto) {\n\n        UsernamePasswordAuthenticationToken authenticationToken =\n                new UsernamePasswordAuthenticationToken(loginDto.getUsername(), loginDto.getPassword());\n\n        Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken);\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n\n        String jwt = tokenProvider.createToken(authentication);\n\n        HttpHeaders httpHeaders = new HttpHeaders();\n        httpHeaders.add(JwtFilter.AUTHORIZATION_HEADER, \"Bearer \" + jwt);\n\n        return new ResponseEntity<>(new TokenDto(jwt), httpHeaders, HttpStatus.OK);\n    }\n}\n```\n\n이전에 만들었던 `TokenProvider`, `AuthenticationManagerBuilder` 를 주입받습니다.\n\n로그인 API 경로는 `/api/authenticate` 경로이고 `POST` 요청을 받습니다.\n\n### authorize 메소드\n\n`authorize` 메소드는 LoginDto의 username, password를 매개변수로 받고 이를 이용해 `UsernamePasswordAuthenticationToken`을 생성합니다.\n\nauthenticationToken을 이용해서 Authentication 객체를 생성하려고 `authenticate` 메소드가 실행이될 때 `CustomUserDetailsService` 클래스의 `loadUserByUsername` 메소드가 실행됩니다.\n\n이 결과값을 이용해서 Authenticaion 객체를 생성하고 이를 SecurityContext 에 저장하고 Authenticaion 객체를 `createToken` 메소드를 통해서 JWT Token 을 생성합니다.\n\nJWT Token 을 Response Header에 넣어주고 TokenDto를 이용해서 Response Body에도 넣어서 리턴하게 됩니다.\n\n# 4. 로그인 API 테스트\n\n자 이제 로그인 API 를 포스트맨으로 테스트해보겠습니다.\n\n## 로그인 요청\n\n [http://localhost:8080/api/authenticate](http://localhost:8080/api/authenticate) 경로로 아래와 같이 `POST` 요청을 보냅니다.\n\n![Untitled](4-1.png)\n\nadmin 계정 정보는 data.sql의 insert문이 서버가 시작될때 자동실행되어 DB에 저장된 상태입니다.\n\n- 405 HTTP 상태 코드가 발생하면?\n    - Server Log\n    \n    ```json\n    2022-01-12 18:35:18.364 DEBUG 5197 --- [nio-8080-exec-1] com.example.jwttutorial.jwt.JwtFilter    : 유효한 JWT 토큰이 없습니다, uri: /api/authenticate\n    2022-01-12 18:35:18.373  WARN 5197 --- [nio-8080-exec-1] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'text/plain;charset=UTF-8' not supported]\n    2022-01-12 18:35:18.374 DEBUG 5197 --- [nio-8080-exec-1] com.example.jwttutorial.jwt.JwtFilter    : 유효한 JWT 토큰이 없습니다, uri: /error\n    ```\n    \n    - Response\n    \n    ```json\n    {\n        \"timestamp\": \"2022-01-12T09:33:18.957+00:00\",\n        \"status\": 415,\n        \"error\": \"Unsupported Media Type\",\n        \"path\": \"/api/authenticate\"\n    }\n    ```\n    \n    위와 같이 응답이 반환되면 POST 요청을 보낼때 `JSON` 형식으로 보내시면됩니다.\n    \n\n## 정상 응답\n\n정상적으로 요청이 응답된다면 서버에선 해당 sql문 query 내용이 로그로 나타납니다\n\n```sql\nHibernate: \n    select\n        user0_.user_id as user_id1_1_0_,\n        authority2_.authority_name as authorit1_0_1_,\n        user0_.activated as activate2_1_0_,\n        user0_.nickname as nickname3_1_0_,\n        user0_.password as password4_1_0_,\n        user0_.username as username5_1_0_,\n        authoritie1_.user_id as user_id1_2_0__,\n        authoritie1_.authority_name as authorit2_2_0__ \n    from\n        user user0_ \n    left outer join\n        user_authority authoritie1_ \n            on user0_.user_id=authoritie1_.user_id \n    left outer join\n        authority authority2_ \n            on authoritie1_.authority_name=authority2_.authority_name \n    where\n        user0_.username=?\n```\n\n그리고 Repsonse 내용으로 아래와 같이 Token이 정상적으로 리턴됩니다.\n\n```json\n{\n    \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImF1dGgiOiJST0xFX0FETUlOLFJPTEVfVVNFUiIsImV4cCI6MTY0MjA2NjU2NH0.QLtuqh874mipMl-h0cO6p4Jf430RGf2uBArr5nWcnmnvG6YqVo0qFXGxEwbPHD9u7J4Zl1GIL0YuWQTXWdUYHA\"\n}\n```\n\n이제 DTO 클래스, Repository, 로그인 API의 개발이 완료되었습니다. \n\n디음 편에서는 회원가입 API를 만들고 회원가입한 유저와 admin 관리자의 권한 검증을 구성하겠습니다.\n\n- Postman의 유용한 기능\n\n![Untitled](4-2.png)\n\n위와 같이 Tests 탭에서 Response의 데이터를 전역변수에 저장해서 다른 Request에서도 사용할 수 있습니다.\n\n# Reference\n\n[Spring Docs - JpaRepository](https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html)","excerpt":"1. DTO 클래스 생성 LoginDto 클래스 외부와의 통신에 사용할 DTO 패키지 및 클래스를 생성합니다. Lombok 어노테이션(Get, Set 등)이 추가되었고 @Valid 관련 어노테이션을 추가했습니다. 로그인 할 이용자의 아이디, 비밀번호…","fields":{"slug":"/springboot-jwt-tutorial4/"},"frontmatter":{"date":"Jan 13, 2022","title":"SpringBoot JWT 튜토리얼 - 4장 DTO,Repository,로그인 구현","tags":["SpringBoot","JWT","튜토리얼"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# 1. JWT 설정추가\n\napplication.yml 파일을 열고, jwt 설정을 추가하겠습니다.\n\n```yaml\njwt:\n  header: Authorization\n  #HS512 알고리즘을 사용할 것이기 때문에 512bit, 즉 64byte 이상의 secret key를 사용해야 한다.\n  #echo 'silvernine-tech-spring-boot-jwt-tutorial-secret-silvernine-tech-spring-boot-jwt-tutorial-secret'|base64\n  secret: c2lsdmVybmluZS10ZWNoLXNwcmluZy1ib290LWp3dC10dXRvcmlhbC1zZWNyZXQtc2lsdmVybmluZS10ZWNoLXNwcmluZy1ib290LWp3dC10dXRvcmlhbC1zZWNyZXQK\n  token-validity-in-seconds: 86400\n```\n\n- header : JWT를 검증하는데 필요한 정보\n- secret : HS512 알고리즘을 사용할 것이기 때문에 512bit, 즉 64byte 이상의 secret key를 사용해야 한다\n    - 위 예제에서는 Secret Key 를 Base64 로 인코딩한 값임.\n- token-validity-in-seconds : 토큰의 만료시간을 지정함 (단위는 초)\n\n이제 build.gradle 파일로 가서 JWT 관련 라이브러리를 추가합니다.\n\n```yaml\nimplementation group: 'io.jsonwebtoken', name: 'jjwt-api', version: '0.11.2'\nruntimeOnly group: 'io.jsonwebtoken', name: 'jjwt-impl', version: '0.11.2'\nruntimeOnly group: 'io.jsonwebtoken', name: 'jjwt-jackson', version: '0.11.2'\n```\n\n그 후 그래들을 다시 불러와, 프로젝트에 의존성을 설치해줍니다. \n\nJWT 개발을 위한 준비는 완료되었고 이제 JWT 코드를 개발하겠습니다.\n\n# 2. JWT 관련 코드 작성\n\n## TokenProvider 클래스\n\njwt 패키지를 생성하고, 토큰의 생성과 토큰의 유효성 검증등을 담당할 Token Provider 를 만들겠습니다.\n\n```java\n@Component\npublic class TokenProvider implements InitializingBean {\n\n    private final Logger logger = LoggerFactory.getLogger(TokenProvider.class);\n\n    private static final String AUTHORITIES_KEY = \"auth\";\n\n    private final String secret;\n    private final long tokenValidityInMilliseconds;\n\n    private Key key;\n\n    public TokenProvider(\n            @Value(\"${jwt.secret}\") String secret,\n            @Value(\"${jwt.token-validity-in-seconds}\") long tokenValidityInSeconds) {\n        this.secret = secret;\n        this.tokenValidityInMilliseconds = tokenValidityInSeconds * 1000;\n    }\n\n    @Override\n    public void afterPropertiesSet() {\n        byte[] keyBytes = Decoders.BASE64.decode(secret);\n        this.key = Keys.hmacShaKeyFor(keyBytes);\n    }\n}\n```\n\n`InitializingBean`  인터페이스를 구현하여, `afterPropertiesSet` 메소드를 Override 한 이유는\n\nBean이 생성이 되고, 의존성 주입을 받은 후에 secret 값을 Base64 Decode 해서 key 변수에 할당합니다.\n\n### createToken 메소드\n\nAuthentication 객체의 권한정보를 이용해서 토큰을 생성하는 createToken 메소드를 추가합니다.\n\n```java\npublic String createToken(Authentication authentication) {\n      String authorities = authentication.getAuthorities().stream()\n         .map(GrantedAuthority::getAuthority)\n         .collect(Collectors.joining(\",\"));\n\n      long now = (new Date()).getTime();\n      Date validity = new Date(now + this.tokenValidityInMilliseconds);\n\n      return Jwts.builder()\n         .setSubject(authentication.getName())\n         .claim(AUTHORITIES_KEY, authorities)\n         .signWith(key, SignatureAlgorithm.HS512)\n         .setExpiration(validity)\n         .compact();\n   }\n```\n\nauthenticaion 객체를 받아서 권한 설정을 하고, application.yml 에서 설정했던 토큰 만료시간을 설정하고 토큰을 생성합니다.\n\n### getAuthenticaion 메소드\n\ntoken을 매개변수로 받아서, 토큰에 담긴 정보를 이용해 Authenticaion 객체를 리턴하는 메소드를 작성합니다.\n\n```java\npublic Authentication getAuthentication(String token) {\n      Claims claims = Jwts\n              .parserBuilder()\n              .setSigningKey(key)\n              .build()\n              .parseClaimsJws(token)\n              .getBody();\n\n      Collection<? extends GrantedAuthority> authorities =\n         Arrays.stream(claims.get(AUTHORITIES_KEY).toString().split(\",\"))\n            .map(SimpleGrantedAuthority::new)\n            .collect(Collectors.toList());\n\n      User principal = new User(claims.getSubject(), \"\", authorities);\n\n      return new UsernamePasswordAuthenticationToken(principal, token, authorities);\n   }\n```\n\ntoken으로 클레임을 만들고, 클레임에서 권한정보를 받아서 유저 객체를 만들어서 최종적으로 Authenticaion 객체를 리턴합니다.\n\n- Claims : JWT 의 속성정보, java 에서 Claims 는 Json map 형식의 인터페이스임\n\n### validateToken 메소드\n\ntoken을 매개변수로 받아서, 토큰의 유효성 검증을 수행하는 validateToken 메소드를 작성합니다.\n\n```java\npublic boolean validateToken(String token) {\n      try {\n         Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);\n         return true;\n      } catch (io.jsonwebtoken.security.SecurityException | MalformedJwtException e) {\n         logger.info(\"잘못된 JWT 서명입니다.\");\n      } catch (ExpiredJwtException e) {\n         logger.info(\"만료된 JWT 토큰입니다.\");\n      } catch (UnsupportedJwtException e) {\n         logger.info(\"지원되지 않는 JWT 토큰입니다.\");\n      } catch (IllegalArgumentException e) {\n         logger.info(\"JWT 토큰이 잘못되었습니다.\");\n      }\n      return false;\n   }\n```\n\n토큰을 파싱하고, 발생하는 예외들을 캐치하여, 문제가 있음면 false, 정상이면 true를 리턴합니다.\n\n## JwtFilter 클래스\n\nJWT를 위한 커스텀 필터를 만들기 위해 JwtFilter 클래스를 생성합니다.\n\n```java\npublic class JwtFilter extends GenericFilterBean {\n\n    private static final Logger logger = LoggerFactory.getLogger(JwtFilter.class);\n\n    public static final String AUTHORIZATION_HEADER = \"Authorization\";\n\n    private TokenProvider tokenProvider;\n\n    public JwtFilter(TokenProvider tokenProvider) {\n        this.tokenProvider = tokenProvider;\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)\n            throws IOException, ServletException {\n        \n    }\n}\n```\n\n- doFilter : JWT 토큰의 인증정보를 현재 실행중인 SecurityContext 에 저장하는 역활\n\nGenericFilterBean을 상속받아 doFilter 메소드를 Override.\n\n실제 필터링 로직은 doFilter 내부에 작성합니다.\n\n### resolveToken 메소드\n\nRequest Header 에서 토큰정보를 가져오기 위한, resolveToken 메소드를 추가합니다.\n\n```java\nprivate String resolveToken(HttpServletRequest request) {\n      String bearerToken = request.getHeader(AUTHORIZATION_HEADER);\n      if (StringUtils.hasText(bearerToken) && bearerToken.startsWith(\"Bearer \")) {\n         return bearerToken.substring(7);\n      }\n      return null;\n   }\n```\n\n### doFilter 메소드 내부 로직\n\n doFilter의 내부 로직을 작성하겠습니다.\n\n```clike\nHttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;\n      String jwt = resolveToken(httpServletRequest);\n      String requestURI = httpServletRequest.getRequestURI();\n\n      if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {\n         Authentication authentication = tokenProvider.getAuthentication(jwt);\n         SecurityContextHolder.getContext().setAuthentication(authentication);\n         logger.debug(\"Security Context에 '{}' 인증 정보를 저장했습니다, uri: {}\", authentication.getName(), requestURI);\n      } else {\n         logger.debug(\"유효한 JWT 토큰이 없습니다, uri: {}\", requestURI);\n      }\n\n      filterChain.doFilter(servletRequest, servletResponse);\n```\n\nresolveToken 을 통해 토큰을 받아와서 유효성 검증을 하고 토큰이 정상적이면 Authenticaion 객체를 받아와서 \n\nSecurityContext 에 저장합니다.\n\n## JwtSecurityConfig 클래스\n\nTokenProvider, JwtFilter 를 SecurityConfig에 적용할때 사용할 JwtSecurityConfig 클래스를 생성합니다.\n\n```java\npublic class JwtSecurityConfig extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity> {\n\n    private TokenProvider tokenProvider;\n\n    public JwtSecurityConfig(TokenProvider tokenProvider) {\n        this.tokenProvider = tokenProvider;\n    }\n\n    @Override\n    public void configure(HttpSecurity http) {\n        JwtFilter customFilter = new JwtFilter(tokenProvider);\n        http.addFilterBefore(customFilter, UsernamePasswordAuthenticationFilter.class);\n    }\n}\n```\n\nSecurityConfigurerAdapter를 상속받고 TokenProvider를 주입받아서 configure 메소드를 Override 하여 JwtFilter를 통해 Security 로직에 필터를 등록합니다.\n\n## JwtAuthenticationEntryPoint 클래스\n\n유효한 자격증명을 제공하지 않고 접근하려 할때 401 Unauthorized 에러를 리턴할 JwtAuthenticationEntryPoint 클래스를 생성합니다.\n\n```java\n@Component\npublic class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {\n\n    @Override\n    public void commence(HttpServletRequest request,\n                         HttpServletResponse response,\n                         AuthenticationException authException) throws IOException {\n        // 유효한 자격증명을 제공하지 않고 접근하려 할때 401\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n    }\n}\n```\n\nAuthneticaionEntryPoint 를 구현하고, commence 메소드를 Override 합니다\n\n이 클래스는 유효하지 않는 자격증명은 401 에러를 전송하는 클래스입니다.\n\n## JwtAccessDeniedHandler 클래스\n\n필요한 권한이 존재하지 않는 경우에 403 Forbidden 에러를 리턴하기 위해 JwtAccessDeniedHandler 클래스를 생성합니다.\n\n```java\n@Component\npublic class JwtAccessDeniedHandler implements AccessDeniedHandler {\n\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException {\n        //필요한 권한이 없이 접근하려 할때 403\n        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n    }\n}\n```\n\nAccessDeniedHandler를 구현하하고, handle 메소드를 Override합니다.\n\n필요한 권한이 없이 접근할때 403 에러를 리턴합니다.\n\n# 3. Security 설정 추가\n\n## SecurityConfig 에 추가\n\n이제 만들었던 5개의 클래스를 SecurityConfig 에 적용하겠습니다.\n\n```java\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    private final TokenProvider tokenProvider;\n    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;\n    private final JwtAccessDeniedHandler jwtAccessDeniedHandler;\n\n    public SecurityConfig(\n            TokenProvider tokenProvider,\n            JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint,\n            JwtAccessDeniedHandler jwtAccessDeniedHandler\n    ) {\n        this.tokenProvider = tokenProvider;\n        this.jwtAuthenticationEntryPoint = jwtAuthenticationEntryPoint;\n        this.jwtAccessDeniedHandler = jwtAccessDeniedHandler;\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    @Override\n    public void configure(WebSecurity web) {\n        web.ignoring()\n                .antMatchers(\n                        \"/h2-console/**\"\n                        ,\"/favicon.ico\"\n                );\n    }\n\n    @Override\n    protected void configure(HttpSecurity httpSecurity) throws Exception {\n        httpSecurity\n                // token을 사용하는 방식이기 때문에 csrf를 disable합니다.\n                .csrf().disable()\n\n                .exceptionHandling()\n                .authenticationEntryPoint(jwtAuthenticationEntryPoint)\n                .accessDeniedHandler(jwtAccessDeniedHandler)\n\n                // enable h2-console\n                .and()\n                .headers()\n                .frameOptions()\n                .sameOrigin()\n\n                // 세션을 사용하지 않기 때문에 STATELESS로 설정\n                .and()\n                .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n\n                .and()\n                .authorizeRequests()\n                .antMatchers(\"/api/hello\").permitAll()\n                .antMatchers(\"/api/authenticate\").permitAll()\n                .antMatchers(\"/api/signup\").permitAll()\n\n                .anyRequest().authenticated()\n\n                .and()\n                .apply(new JwtSecurityConfig(tokenProvider));\n    }\n}\n```\n\n- `@EnableGlobalMethodSecurity` : @PreAuthorize 어노테이션을 메소드 단위로 추가한다\n\nSecurityConfig는 TokenProvider, JwtAuthenticaionEntryPoint, JwtAccessDeniedHandler 를 주입받습니다. \n\npasswordEncoder로 BCryptPasswordEncoder를 사용합니다.\n\nconfigure 메소드에서 많은 부분이 추가됬는데(HttpSecurity 매개인자) \n\n일단 토큰을 사용하기 때문에 csrf 는 disable 합니다 Exception을 핸들링할때 우리가 작성한 클래스를 추가합니다.\n\n그리고 h2-console 을 위한 설정들을 추가해줬고, 우리는 세션을 사용하지 않기 때문에 세션 설정을 STATELESS로 설정합니다.\n\n로그인 API, 회원가입 API 는 토큰이 없는 상태에서 요청이 들어오기 때문에 모두 permitAll 설정을 해줬습니다.\n\n마지막으로 JwtFilter를 addFilterBefore로 등록했던 JwtSecurityConfig 클래스도 적용해줍니다.\n\n### 서버 실행\n\n서버를 최종적으로 실행하면 아무 오류없이 잘 실행되는 것을 볼수있습니다.\n\n```java\n2022-01-10 20:36:56.570  INFO 44384 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''\n2022-01-10 20:36:56.575  INFO 44384 --- [           main] c.e.jwttutorial.JwtTutorialApplication   : Started JwtTutorialApplication in 2.078 seconds (JVM running for 2.671)\n```\n\n이제 JWT 설정 추가, JWT 관련 코드 개발, Security 설정 추가하는 작업이 완료되었습니다.\n\n다음편에서는 DB와 연결하는 Repository를 만들고 로그인 API 를 구현하겠습니다.","excerpt":"1. JWT 설정추가 application.yml 파일을 열고, jwt 설정을 추가하겠습니다. header : JWT를 검증하는데 필요한 정보 secret : HS512 알고리즘을 사용할 것이기 때문에 512bit, 즉 64byte 이상의 secre…","fields":{"slug":"/springboot-jwt-tutorial3/"},"frontmatter":{"date":"Jan 12, 2022","title":"SpringBoot JWT 튜토리얼 - 3장 JWT코드, Security 설정 추가","tags":["SpringBoot","JWT","튜토리얼"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# 1. JWT (Json Web Token)란?\n\n---\n\n- JSON 객체를 사용해서 토큰 자체에 정보를 저장하는 Web Token\n- Header, Payload, Signature 3개 부분으로 구성됨.\n- 쿠키나 세션을 이용한 인증보다 안전하고 효율적임\n- 일반적으로는 `Authorization : <type> <credentials>` 형태로 Request Header 에 담겨져 오기 떄문에 Header 값을 확인해서 가져올 수 있음.\n\n## 1.1 장단점\n\n---\n\n- 장점\n    - 중앙 인증 서버, 저장소에 대한 의존성이 없어서 수평확장에 유리\n    - Base64 URL Safe Encoding 이라 URL, Cookie, Header 어떤 형태로 사용가능\n    - Stateless 한 서버 구현 가능\n    - 웹이 아닌 모바일에서도 사용 가능\n    - 인증 정보를 다른 곳에서도 사용 가능 (OAuth)\n- 단점\n    - Payload 의 정보가 많아지면 네트워크 사용량 증가\n    - 다른 사람이 토큰을 decode 하여 데이터 확인 가능\n    - 토큰을 탈취당한 경우 대처하기 어려움\n        - 기본적으로는 서버에서 관리하는게 아니다보니 탈취당한 경우 강제 로그아웃 처리가 불가능\n        - 토큰 유효시간이 만료되기 전까지는 탈취자는 자유롭게 인증 가능\n        - 그래서 유효시간을 짧게 가져가고 refresh Token 을 발급하는 방식으로 많이 사용\n\n## 1.2 Token 구성요소\n\n---\n\n- Header\n    - `alg` : Signature 를 해싱하기 위한 알고리즘 정보를 갖고 있음\n    - `typ` : 토큰의 타입을 나타내는데 없어도 됨(보통 JWT 를 사용)\n- Payload\n    - 서버와 클라이언트가 주고받는, 시스템에서 실제로 사용될 정보에 대한 내용을 담고 있음\n    - JWT가 [기본적으로 갖고 있는 키워드](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1)가 존재\n    - 원한다면 추가 가능\n        - `iss` : 토큰 발급자\n        - `sub` : 토큰 제목\n        - `aud` : 토큰 대상\n        - `exp` : 토큰의 만료시간\n        - `nbf` : Not Before\n        - `iat` : 토큰이 발급된 시간\n        - `jti` : JWT의 고유 식별자\n- Signature\n    - 서버에서 토큰이 유효한지 검증하기 위한 문자열\n    - Header + Payload + Secret Key 로 값을 생성하므로 데이터 변조 여부를 판단 가능\n    - Secret Key 는 노출되지 않도록 서버에서 관리 필요\n\n## 1.3 토큰 인증 타입\n\n---\n\n`Authorization: <type> <credentials>` 형태에서 `<type>` 부분에 들어값 값.\n\n엄격한 규칙이 있는건 아니고, 일반적으로 많이 사용되는 형태\n\n- Basic\n    - 사용자 아이디와 암호를 Base64로 인코딩한 값을 토큰으로 사용\n- Bearer\n    - JWT 또는 OAuth 에 대한 토큰을 사용\n- Digest\n    - 서버에서 난수 데이터 문자열을 클라이언트에 보냄\n    - 클라이언트는 사용자 정보와 nonce 를 포함하는 해시값을 사용하여 응답\n- HOBA\n    - 전자 서명 기반 인증\n- Mutual\n    - 암호를 이용한 클라이언트-서버 상호 인증\n- AWS4-HMAC-SHA256\n    - AWS 전자 서명 기반 인증\n\n# 2. Refresh Token\n\n---\n\n**JWT 역시 탈취되면 누구나 API 를 호출할 수 있다는 [단점이](https://www.notion.so/JWT-6b901ef070744b6bb65fff7f5343fd35) 존재.**\n\n세션은 탈취된 경우 세션 저장소에서 탈취된 세션 ID를 삭제하면되지만, JWT 는 서버에서 관리하지 않기 때문에 속수무책으로 당할 수 밖에 없음.\n\n그래서 탈취되어도 피해가 최소한 되도록 유효시간을 짧게 가져감.\n\n하지만 만료 시간을 30분으로 설정하면 일반 사용자는 30분마다 새로 로그인하여 토큰을 발급받아야 함.\n\n**사용자가 매번 로그인 하는 과정을 생략하기 위해 필요한게 Refresh Token.**\n\n### 발급 과정\n\n1. Refresh Token 은 로그인 토큰(Access Token) 보다 긴 유효 시간을 가지며, Access Token 이 만료된 사용자가 재발급을 원할 경우 Refresh Toekn을 함께 전달함.\n2. 서버는 Access Token 에 담긴 사용자의 정보를 확인하고 Refresh Token 이 아직 만료되지 않았다면, 새로운 토큰을 발급해줌\n\n위와 같이 하면 매번 로그인해야하는 번거로움 없이 로그인을 지속적으로 유지 할 수 있음.\n\n### 주의\n\nRefresh Token 은 사용자가 로그인할 때 같이 발급되며, 클라이언트가 안전한 곳에 보관하고 있어야 함.\n\nAccess Token과 달리 매 요청마다 주고 받지 않기 때문에 탈취 당할 위험이 적으며, 요청 주기가 길기 때문에 별도의 저장소에 보관함. (정책마다 다르게 사용)\n\n## 2.1 Refresh Token 저장소\n\n---\n\nRefresh Token 은 서버에서 별도의 저장소에 보관하는 것이 좋다.\n\n- Refresh Token 은 사용자 정보가 없기 때문에 저장소에 값이 있으면 검증 시 어떤 사용자의 토큰인지 판단하기 용이\n- 탈취당했을 때 저장소에서 Refresh Token 정보를 삭제하면 Access Token 만료 후에 재발급이 안되게 강제 로그아웃 처리 가능\n- 일반적으로 Redis 많이 사용\n\n## 2.2 Refresh Token 으로 Access Token 재발급 시나리오\n\n---\n\n1. 클라이언트는 `access token` 으로 API 요청하며 서비스 제공\n2. `access token` 이 만료되면 서버에서 `access token` 만료 응답을 내려줌\n3. 클라이언트는 access token 만료응답을 받고 재발급을 위해 `access token + refresh token` 을 함께 보냄\n4. 서버는 `refresh token` 의 만료 여부를 확인\n5. `acces token` 으로 유저 정보(username 또는 userid) 를 획득하고 저장소에 해당 유저 정보를 key 값으로 한 value 가 `refresh token` 과 일치하는지 확인\n6.  4 - 5 번의 검증이 끝나면 새로운 토큰 세트 (access + refresh ) 발급\n7. 서버는 `refresh token` 저장소의 value 업데이트\n\n## 참고\n\n- [JWT Token 확인 가능한 사이트](https://jwt.io)\n- [참고한 블로그](https://bcp0109.tistory.com/321)","excerpt":"1. JWT (Json Web Token)란? JSON 객체를 사용해서 토큰 자체에 정보를 저장하는 Web Token Header, Payload, Signature 3개 부분으로 구성됨. 쿠키나 세션을 이용한 인증보다 안전하고 효율적임 일반적으로는…","fields":{"slug":"/json-web-token/"},"frontmatter":{"date":"Jan 10, 2022","title":"Json Web Token(JWT) 란?","tags":["보안","Token"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"## 1. 401 Unauthorized 해결을 위한 Security 설정\n\n### SecurityConfig 생성\n\n![Untitled](2-1.png)\n\nconfig 패키지를 생성한뒤, SecurityConfig 클래스를 작성합니다.\n\n- SecurityConfigurer 설정을 위한 두가지 방법\n    1. `WebSecurityConfigurer` 를 `implements` 하기\n    2. `WebSecurityConfigurerAdapter` 를 `extends` 하기\n    \n    위 코드에서는 2번째 방법으로 어댑터 클래스를 상속받아서 구현한다.\n    \n- `configure(HttpSecurity http)` 메소드 오바라이딩\n    \n    상속받은 클래스 내부를 보면, configure 함수가 오버로딩되어있는데, 이 코드에서는 HTTPSecurity 를 매개변수로 가지는 함수를 오버라이딩하여 작성한다.\n    \n- `authorizeRequests()`\n    - HttpServletRequest 를 사용한 요청들에 대한 접근제한\n    - HttpServletRequest?\n        \n        JSP 기본 내장 객체 중 **request 객체는 JSP에서 가장 많이 사용되는 객체**입니다.\n        \n        웹브라우저 사용자인 클라이언트로부터 서버로 요청이 들어오면 서버에서는 **HttpServletRequest**  를 생성하며, 요청정보에 있는 패스로 매핑된 서블릿에게 전달합니다.\n        \n        이렇게 전달받은 내용들을 파라미터로 Get과 Post 형식으로 클라이언트에게 전달합니다.\n        \n- `antMatchers(path).permitAll()`\n    - 해당 path 는 인증없이(permitAll) 접근허용한다.\n- `anyRequest().authenticated()`\n    - 그외 나머지 요청들은 인증되어야한다.\n\n### Postman으로 테스트\n- GET - localhost:8080/api/hello\n\n![Untitled](2-2.png)\n\n위와 같이 문자열 “hello” 가 반환이 된것을 볼수있습니다.\n\n## 2. Datasource, JPA 설정\n\n### properties → yml 로 변경\n\n기본적으로 스프링부트는 key - value 형식을 사용하는 [application.properties](http://application.properties) 파일이 있습니다.\n\n키에 동일한 접두사를 사용하여, 계층적 데이터를 표현합니다.\n\n해당 파일의 각 라인은 단일 구성이고, 모든 키는 spring.datasource에 속합니다.\n\n```\nspring.datasource.url=jdbc:h2:dev\nspring.datasource.username=SA\nspring.datasource.password=password\n```\n\nYAML 형식은 계층적 구성 데이터를 지정하기 편리한 형식입니다.\n\n```yaml\nspring:\n    datasource:\n        password: password\n        url: jdbc:h2:dev\n        username: SA\n```\n\n따라서 위 두가지 차이를 보면, YAML 형식은 가독성이 좋고, 하나의 파일로, 프로필을 구분할 수 있는 장점이있다.\n\n보기 좋은 것을 선호하면 YAML 형식을 사용하거나, 이전 형식대로 사용해도 상관없습니다.\n\n인텔리제이의 Refactor를 이용해 application.properties 의 확장자를 yml로 변경합니다.\n\n![Untitled](2-3.png)\n\nH2 데이터베이스를 사용할 것 이고, 메모리에 데이터를 저장합니다.\n\n- h2.console.enabled\n    - h2 콘솔 페이지 활성화\n- jpa.hibernate.ddl-auto\n    - Hibernate 초기화 전략, create-drop 은 인-메모리 DB 기본 전략입니다.\n    - SessionFactory가 시작될 때, Drop, Create, Alter 종료될때 Drop\n- jpa.properties.hibernate\n    - 콘솔창에서 sql 문을 보기좋게 출력\n- logging.level\n    - log4j 의 로그레벨은 ALL < DEBUG < INFO < WARN < ERROR < FATAL < OFF 순으로 지정.\n\n## 3. Entity 생성\n\nentity 패키지를 생성하고, User, Authority 를 생성합니다.\n\n```java\n@Entity\n@Table(name = \"user\")\n@Getter\n@Setter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User {\n\n    @Id\n    @Column(name = \"user_id\")\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long userId;\n\n    @Column(name = \"username\", length = 50, unique = true)\n    private String username;\n\n    @Column(name = \"password\", length = 100)\n    private String password;\n\n    @Column(name = \"nickname\", length = 50)\n    private String nickname;\n\n    @Column(name = \"activated\")\n    private boolean activated;\n\n    @ManyToMany\n    @JoinTable(\n            name = \"user_authority\",\n            joinColumns = {@JoinColumn(name = \"user_id\", referencedColumnName = \"user_id\")},\n            inverseJoinColumns = {@JoinColumn(name = \"authority_name\", referencedColumnName = \"authority_name\")})\n    private Set<Authority> authorities;\n}\n```\n\n```java\npackage com.example.jwttutorial.entity;\n\nimport lombok.*;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Id;\nimport javax.persistence.Table;\n\n@Entity\n@Table(name = \"authority\")\n@Getter\n@Setter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Authority {\n\n    @Id\n    @Column(name = \"authority_name\", length = 50)\n    private String authorityName;\n}\n```\n\n![Untitled](2-4.png)\n\nUser 클래스를 보면 @ManyToMany, @JoinTable 은 유저와 권한 객체의 다대다 관계를 위 테이블 처럼 일대다, 다대일 관계의 조인 테이블로 정의했습니다. \n\n이 부분은 추후 강의자의 JPA 강의에서 자세히 설명합니다. \n\n### data.sql 생성\n\n편의를 위해, 서버를 시작할때마다 Data를 자동으로 DB에 넣어주는 기능을 활용하겠습니다.\n\n resource 폴더 밑에 data.sql 파일을 만들겠습니다.\n\n```sql\nINSERT INTO USER (USER_ID, USERNAME, PASSWORD, NICKNAME, ACTIVATED) VALUES (1, 'admin', '$2a$08$lDnHPz7eUkSi6ao14Twuau08mzhWrL4kyZGGU5xfiGALO/Vxd5DOi', 'admin', 1);\nINSERT INTO USER (USER_ID, USERNAME, PASSWORD, NICKNAME, ACTIVATED) VALUES (2, 'user', '$2a$08$UkVvwpULis18S19S5pZFn.YHPZt3oaqHZnDwqbCW9pft6uFtkXKDC', 'user', 1);\n\nINSERT INTO AUTHORITY (AUTHORITY_NAME) values ('ROLE_USER');\nINSERT INTO AUTHORITY (AUTHORITY_NAME) values ('ROLE_ADMIN');\n\nINSERT INTO USER_AUTHORITY (USER_ID, AUTHORITY_NAME) values (1, 'ROLE_USER');\nINSERT INTO USER_AUTHORITY (USER_ID, AUTHORITY_NAME) values (1, 'ROLE_ADMIN');\nINSERT INTO USER_AUTHORITY (USER_ID, AUTHORITY_NAME) values (2, 'ROLE_USER');  \n```\n\n## 4. H2 Console 결과 확인\n\n우리가 만들었던 엔티티들이 DB에 생성이 되는지 확인을 해봅니다. \n\n그 전에 Security 설정을 추가해줘야지 h2-console 접근을 원할하게 할 수 있습니다.\n\n![Untitled](2-5.png)\n\nh2-console 하위 모든 요청들과 파비콘 관련 요청은 Spring Security 로직을 수행하지 않고 접근할 수 있도록 \n\nconfigure(WebSecurity) 메소드를 오버라이딩 합니다.\n\n그 후 서버를 시작합니다.\n\n- DB 초기화 중 에러 발생\n    \n    ```java\n    2022-01-07 16:36:18.468  WARN 2873 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSourceScriptDatabaseInitializer' defined in class path resource [org/springframework/boot/autoconfigure/sql/init/DataSourceInitializationConfiguration.class]: Invocation of init method failed; nested exception is org.springframework.jdbc.datasource.init.ScriptStatementFailedException: Failed to execute SQL script statement #1 of URL [file:/Users/seonghun/Desktop/dev/projects/jwt-tutorial/build/resources/main/data.sql]: INSERT INTO USER (USER_ID, USERNAME, PASSWORD, NICKNAME, ACTIVATED) VALUES (1, 'admin', '$2a$08$lDnHPz7eUkSi6ao14Twuau08mzhWrL4kyZGGU5xfiGALO/Vxd5DOi', 'admin', 1); \n    nested exception is org.h2.jdbc.JdbcSQLSyntaxErrorException: Table \"USER\" not found; SQL statement:\n    \n    INSERT INTO USER (USER_ID, USERNAME, PASSWORD, NICKNAME, ACTIVATED) VALUES (1, 'admin', '$2a$08$lDnHPz7eUkSi6ao14Twuau08mzhWrL4kyZGGU5xfiGALO/Vxd5DOi', 'admin', 1) [42102-200]\n    ```\n    <br/>\n    hibernate 초기화 과정에 에러가 발생했습니다.\n    \n    Spring Boot Application 구동하는 과정 중에 `data.sql`을 실행하는 도중, User 테이블을 찾을 수 없어 Insert 구문에서 오류가 발생하는 것인데. \n    \n    강의에서 스프링부트의 버전은 2.4이고 현재 2.6 인데 버전이 업데이트 되면서 이러한 오류가 발생하는 듯 합니다.(대부분의 오류는 버전업데이트 관련을 많이겪음)\n    <br/>\n    - Hibernate and data.sql 공식 노트 내용 ([릴리즈 노트 링크)](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.5-Release-Notes)\n    \n    > By default, data.sql scripts are now run before Hibernate is initialized. This aligns the behavior of basic script-based initialization with that of Flyway and Liquibase. If you want to use data.sql to populate a schema created by Hibernate, set spring.jpa.defer-datasource-initialization to true. While mixing database initialization technologies is not recommended, this will also allow you to use a schema.sql script to build upon a Hibernate-created schema before it’s populated via data.sql.\n    > \n    \n    Spring Boot 2.5버전 부터 스크립트 기반 초기화의 동작과정을 Flyway, Liquibase와 일치시키기 위해서 `data.sql` 은 Hibernate 초기화되기 전에 실행된다는 내용인것 같습니다.\n    \n    따라서 Hibernate 초기화를 통해 생성된 스키마에다가 데이터를 채우기를 위해서 `data.sql`가 실행되기를 원한다면 **application.yml**(또는 properties)에 **`spring.jpa.defer-datasource-initialization`** 옵션 값을 **true**로 추가해주어야 합니다. \n    \n    또는 `schema.sql`을 추가해서 hibernate 가 스키마를 생성하는 과정보다 먼저 실행되도록하여 해당 스키마에 data.sql을 채우도록하는 방법도 있다고 합니다. 그러나 DB 초기화 기술을 혼합하여 사용하는 것은 권장하지 않는 방법이라고 합니다.\n    \n    따라서 application.yml 에 `defer-datasource-initialization: true` 옵션을 권장하지 않지만 추가합니다.\n    \n\n```sql\n2022-01-07 16:43:40.706  INFO 2951 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect\nHibernate: \n    \n    drop table if exists authority CASCADE \nHibernate: \n    \n    drop table if exists user CASCADE \nHibernate: \n    \n    drop table if exists user_authority CASCADE \nHibernate: \n    \n    create table authority (\n       authority_name varchar(50) not null,\n        primary key (authority_name)\n    )\nHibernate: \n    \n    create table user (\n       user_id bigint generated by default as identity,\n        activated boolean,\n        nickname varchar(50),\n        password varchar(100),\n        username varchar(50),\n        primary key (user_id)\n    )\nHibernate: \n    \n    create table user_authority (\n       user_id bigint not null,\n        authority_name varchar(50) not null,\n        primary key (user_id, authority_name)\n    )\nHibernate: \n    \n    alter table user \n       add constraint UK_sb8bbouer5wak8vyiiy4pf2bx unique (username)\nHibernate: \n    \n    alter table user_authority \n       add constraint FK6ktglpl5mjosa283rvken2py5 \n       foreign key (authority_name) \n       references authority\nHibernate: \n    \n    alter table user_authority \n       add constraint FKpqlsjpkybgos9w2svcri7j8xy \n       foreign key (user_id) \n       references user\n```\n\nHibernate DB 초기화 오류를 해결하고 실행을 하니, 로그에 SQL 문을 볼수있습니다. \n\n이 로그들을 보면, 우리가 만들어둔 Entity 내용들을 기반으로 DB 관련 정보들을 생성하는 쿼리들이 잘 수행 된것을 볼수있습니다.\n\n### 실제 DB 반영 확인\n\n[localhost:8080/h2-console](http://localhost:8080/h2-console) 에 접속합니다. (인증을 무시하도록 설정했으므로,접속이 잘 되야합니다)\n\n![Untitled](2-6.png)\n\n우리가 만들었던 Entity 정보들과 data.sql 파일의 쿼리내용들이 잘 들어와있는것을 볼수있습니다.\n\n다음 강의에는 JWT 관련 코드들을 작성하겠습니다.\n\n### Reference\n\n[HttpServletRequest 개념](https://chobopark.tistory.com/43)\n\n[properties → YAML](https://devgoat.tistory.com/15)\n\n[log4j loggin level](https://myblog.opendocs.co.kr/archives/950)\n\n[hibernate ddl-auto 초기화전략](https://pravusid.kr/java/2018/10/10/spring-database-initialization.html)\n\n[스프링부트 2.5 hibernate data.sql](https://velog.io/@khsb2012/스프링-부트-2.5-업데이트-hibernate-data.sql-관련-변동사항)","excerpt":"1. 401 Unauthorized 해결을 위한 Security 설정 SecurityConfig 생성  config 패키지를 생성한뒤, SecurityConfig 클래스를 작성합니다. SecurityConfigurer 설정을 위한 두가지 방법  를 …","fields":{"slug":"/springboot-jwt-tutorial2/"},"frontmatter":{"date":"Jan 08, 2022","title":"SpringBoot JWT 튜토리얼 - 2장 Security 설정, Data 설정","tags":["SpringBoot","JWT","튜토리얼"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n인프런 강의(Spring Boot JWT Tutorial)를 수강하며, 내용들을 기록한 페이지입니다.\n\n- 배우는 것\n    - Spring Boot를 이용한 JWT 인증, 인가 구현\n    - Spring Security 기초\n    - 회원가입, 로그인, 권한로직\n\n# JWT 소개 ([JWT.io](http://JWT.io) [홈페이지](https://jwt.io))\n\n---\n\n![Untitled](1-1.png)\n\nJWT 는 Json 객체를 사용하여 토큰 자체에 정보들을 저장하고 있는 Web Token 이라 할 수 있다.\n\n특히, JWT를 이용하는 방식은 헤비하지 않고 아주 간편하고 쉽게 적응할 수 있다.\n\n- JWT 는 Header, Payload, Signature  3개의 부분으로 구성되어 있다.\n    - Header : Signature 를 해싱하기 위한 알고리즘 정보들이 담김\n    - Payload :  서버와 클라이언트가 주고받는, 시스템에서 실제로 사용될 정보에 대한 내용들을 담고있다.\n    - Signature : 토큰의 유효성 검증을 위한 문자열\n- 장점\n    - 중앙의 인증서버, 데이터 스토어에 대한 의존성 없음, 수평확장에 유리\n    - Base64 URL Safe Encoding  > URL, Cookie, Header 모두 사용 가능\n- 단점\n    - Payload 의 정보가 많아지면 네트워크 사용량 증가, 데이터 설계 고려 필요\n    - 토큰이 클라이언트에 저장, 서버에서 클라이언트의 토큰을 조작할 수 없음\n\n## 프로젝트 생성\n\n---\n\n### 1. 스프링 이니셜라이저를 통한 프로젝트 생성\n\n![Untitled](1-2.png)\n\n- 프로젝트 메타데이터를 입력한다\n- 자바 버전은 8\n- 빌드 도구는 Gradle\n\n![Untitled](1-3.png)\n\n- 스프링 부트 버전은 2.6.2 (강좌는 2.4.1임)\n- 추가한 의존성\n    - Lombok (편의성)\n    - Spring Web\n    - Spring Security\n    - h2 Database\n    - Spring Data JPA\n    - Validation\n    \n\n![Untitled](1-5.png)\n\n- 프로젝트가 생성된 모습\n\n![Untitled](1-4.png)\n\n- Lombok을 사용하므로 Enable annotaion processing 을 체크하자.\n\n### 2. 간단한 Rest API 테스트\n\n![Untitled](1-6.png)\n\n간단한 문자열(hello)을 리턴해주는 api를 만들고 테스트해보겠습니다.\n\n- `RestController` : 컨트롤러를 JSON을 반환하는 컨트롤러로 만들어 줍니다.\n- `RequestMapping` : 요청에 대해 어떤 Controller가 처리할지를 맵핑하기 위한 어노테이션.\n- `GetMapping` : HTTP Method인 Get인 요청을 받을 수 있는 API를 만들어 준다.\n- `ResponseEntity<>` : 사용자의 HttpRequest에 대한 응답 데이터를 포함하는 클래스.\n- `ResponseEntity.ok()`: 정상적인 요청이면 메소드의 파라미터 내용을 반환한다.\n\n위 코드를 작성하고 애플리케이션을 실행하고 Postman을 통해서 해당 url로 요청을 보내겠습니다.\n\n![Untitled](1-7.png)\n\n요청을 보내면 401 HTTP 상태 코드가 반환된 것을 볼 수 있습니다.\n\n이를 해결하기 위한 Security 설정과, 기본적인 Data 설정을 하겠습니다.\n\n### Reference\n\n- [ResponseEntity 스프링 공식 문서](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html)","excerpt":"인프런 강의(Spring Boot JWT Tutorial)를 수강하며, 내용들을 기록한 페이지입니다. 배우는 것 Spring Boot를 이용한 JWT 인증, 인가 구현 Spring Security 기초 회원가입, 로그인, 권한로직 JWT 소개 (JW…","fields":{"slug":"/springboot-jwt-tutorial1/"},"frontmatter":{"date":"Jan 07, 2022","title":"SpringBoot JWT 튜토리얼 - 1장 JWT소개,프로젝트생성","tags":["SpringBoot","JWT","튜토리얼"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# asdf란? ([asdf 설치 하기](https://subicura.com/mac/dev/terminal-apps.html#asdf))\n\nasdf-vm은 각종 프로그램의 버전을 손쉽게 관리해주는 **성의 없어 보이는 이름**의 도구입니다.<br/>\n기존에 nvm, rbenv등 언어, 프로그램별로 달랐던 관리 도구를 하나로 통합해서 사용할 수 있습니다. <br/>\nhomebrew도 일부 버전 관리 기능을 제공하지만 asdf만큼 강력하지 않습니다.<br/>\nasdf를 이용하면 버전 별로 설치할 수 있는 장점이 있습니다.<br/>\n그래서 이번에는 Java 8 JDK와, Java 11 JDK 를 둘다 설치하는 것을 해보겠습니다.<br/>\n\n### 주의\n\n맥 OS 가 아닌 분들을 아쉽지만 들어온 문으로 나가주세요. \n\n## 시작\n\n```json\n❯ java --version\nopenjdk 11.0.13 2021-10-19 LTS\nOpenJDK Runtime Environment Zulu11.52+13-CA (build 11.0.13+8-LTS)\nOpenJDK 64-Bit Server VM Zulu11.52+13-CA (build 11.0.13+8-LTS, mixed mode)\n```\n\n현재 저의 자바 jdk 버전은 11입니다. 저는 jdk 8 버전의 자바 환경도 만들고 싶습니다. \n<br/>그럴려면 환경변수도 매번 지정해줘야하는 번거로움이 있습니다. \n<br/>asdf 를 이용해서 8버전과 11버전을 유연하게 돌아가며 사용할 수 있는 환경을 만들어 보겠습니다.\n\n### 이전에 이미 설치한 JAVA JDK 는 어떡합니까?\n\n만약 brew를 통해서 java를 설치하신 분이라면 brew uninstall 을 통해 jdk를 삭제하면 되고.\n\n아니면 아래 명령어를 통해 삭제하시면 됩니다.\n\n```json\n❯ sudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin\n❯ sudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefPane\n❯ sudo rm -fr ~/Library/Application\\ Support/Java\n\n❯ cd /Library/Java/JavaVirtualMachines/ \n❯ ls \n❯ sudo -rm -rf jdk-x.x.x.jdk\n```\n\n### JAVA Plugin 추가\n\n[asdf-java plugin 깃허브 링크](https://github.com/halcyon/asdf-java#java_home)\n\n- 먼저 자바 플러그인을 추가합니다\n\n```json\n❯ asdf plugin-add java https://github.com/halcyon/asdf-java.git\n```\n\n### 자바 플러그인 업데이트\n\n플러그인 목록을 최신화합니다.\n\n```json\n❯ asdf plugin update java\n```\n\n### 자바 버전 별 플러그인 보기\n\n아래 명령어를 이용하면 설치할 수 있는 자바의 버전들이 나타납니다.\n\n```json\n❯ asdf list-all java\n...\nsapmachine-jre-18-internal.0\ntemurin-17.0.0+35\ntemurin-17.0.1+12\ntemurin-jre-17.0.1+12\nzulu-8.52.0.23\nzulu-8.54.0.21\nzulu-8.56.0.23\nzulu-8.58.0.13\nzulu-11.43.1017\nzulu-11.43.1021\nzulu-11.45.27\nzulu-11.48.21\nzulu-11.50.19\nzulu-11.52.13\nzulu-13.35.1019\nzulu-13.35.1025\nzulu-13.37.21\nzulu-13.40.15\nzulu-13.42.17\nzulu-13.44.13\nzulu-15.28.1013\nzulu-15.29.15\nzulu-15.32.15\nzulu-15.34.17\nzulu-15.36.13\nzulu-16.28.11\nzulu-16.30.15\nzulu-16.30.19\nzulu-16.32.15\nzulu-17.28.13\nzulu-17.30.15\n...\n```\n\n(오라클 jdk는 설치안하는것을 추천합니다. [[JDK 라이선스 유료화]](https://zdnet.co.kr/view/?no=20181102140004)\n\n### JAVA 8, 11 버전 설치\n\n자바 8버전과 11버전의 openjdk를 설치하겠습니다.\n\n```json\n❯ asdf install java zulu-8.58.0.13\n❯ asdf install java zulu-11.52.13\n```\n\n### asdf 설치한 자바 버전 확인하기\n\n아래 명령어를 통해, 설치된 자바 버전들을 볼수있습니다.\n\n```json\n❯ asdf list java\n  zulu-11.52.13\n  zulu-8.58.0.13\n```\n\n### Global 버전으로 지정하기\n\n설치한 버전을 전역 버전으로 지정합니다. 즉 내 컴퓨터의 자바 버전을 지정한 버전으로 설정합니다.\n\n저는 8버전을 지정했습니다.\n\n```json\n❯ asdf global java zulu-8.58.0.13\n```\n\n### JAVA_HOME 설정하기\n\n[sadf java-plugin JAVA_HOME 설정](https://github.com/halcyon/asdf-java#java_home)\n\n아래 명령어를 실행하면, 자바 위치를 지정합니다. (처음 한번만 실행하면 됩니다)\n\n```json\n. ~/.asdf/plugins/java/set-java-home.zsh\n```\n\n### 자바 버전 확인하기\n\n아래 명령어를 통해 정상적으로 설치되었는지 확인합니다.\n\n```json\n❯ java -version\nopenjdk version \"1.8.0_312\"\nOpenJDK Runtime Environment (Zulu 8.58.0.13-CA-macos-aarch64) (build 1.8.0_312-b07)\nOpenJDK 64-Bit Server VM (Zulu 8.58.0.13-CA-macos-aarch64) (build 25.312-b07, mixed mode)\n```\n\n정상적으로 8버전의 jdk가 나오는 것을 볼 수 있습니다.\n\n또한 자바 환경 변수 위치까지 jdk 8로 변경된 것 을 볼 수 있습니다.\n\n```json\n❯ echo $JAVA_HOME\n/Users/seonghun/.asdf/installs/java/zulu-8.58.0.13/zulu-8.jdk/Contents/Home\n```\n\n### 현재 전역으로 설정된 버전들 보기\n\n자바 뿐만 아니라 다른 프로그램들의 버전 현황을 볼 수 있습니다. (global version)\n\n```json\n❯ asdf current\njava            zulu-8.58.0.13  /Users/seonghun/.tool-versions\nnodejs          lts-fermium     Not installed. Run \"asdf install nodejs lts-fermium\"\nyarn            1.22.17         /Users/seonghun/.tool-versions\n```\n\n### 자바 버전 변경하기\n\n아래 명령어를 통해 11버전의 자바 jdk 로 변경하겠습니다.\n\n```json\n❯ asdf global java zulu-11.52.13\n```\n\n그 후 정상적으로 버전이 변경됬는지 확인하겠습니다.\n\n```json\n❯ java --version\nopenjdk 11.0.13 2021-10-19 LTS\nOpenJDK Runtime Environment Zulu11.52+13-CA (build 11.0.13+8-LTS)\nOpenJDK 64-Bit Server VM Zulu11.52+13-CA (build 11.0.13+8-LTS, mixed mode)\n```\n\n8버전에서 11버전으로 변경된 것 을 확인할 수 있습니다.\n\n아래 명령어로 자바 환경변수 경로까지 자동으로 변경된 것 을 볼수있습니다.\n\n```json\n❯ echo $JAVA_HOME\n/Users/seonghun/.asdf/installs/java/zulu-11.52.13/zulu-11.jdk/Contents/Home\n```\n\n### 결론\n\n`asdf globale java <version>` 명령어 한 줄 만으로 자바 버전을 쉽게 변경할 수 있었습니다.\n\n(원래라면 자바 버전을 버전마다 변수로 추가해줘야함)\n\n자바 뿐만 아니라 npm, yarn 같은 패키지 매니저 또한 지원하니 검색해서 유용하게 쓰시면 되겠습니다.\n\n---\n\n[참고](https://www.wiserfirst.com/blog/install-java-with-asdf/)\n\n[subicura 님 mac asdf 설치](https://subicura.com/mac/dev/terminal-apps.html#asdf/)\n\n[맥에서 Brew로 자바 설치하기(자바 버전 바꾸기)](https://llighter.github.io/install-java-on-mac/)","excerpt":"asdf란? (asdf 설치 하기) asdf-vm은 각종 프로그램의 버전을 손쉽게 관리해주는 성의 없어 보이는 이름의 도구입니다.\n기존에 nvm, rbenv등 언어, 프로그램별로 달랐던 관리 도구를 하나로 통합해서 사용할 수 있습니다. \nhomebr…","fields":{"slug":"/asdf-java/"},"frontmatter":{"date":"Jan 05, 2022","title":"asdf 를 이용한 JAVA 버전 별 설치","tags":["JAVA","자바","asdf"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"## Spring Security란?\n\n- Spring 기반의 애플리케이션의 보안(인증과 권한, 인가 등)을 담당하는 스프링 하위 프레임워크\n- **인증**과 **권한**에 대한 부분을 **Filter** 흐름에 따라 처리\n    - Filter는 Dispatcher Servlet 으로 가기전에 적용\n    - 따라서 가장 먼저 URL 요청을 받는다.\n    - 하지만, Interceptor는 Dispatcher와 Contoller 사이에 위치한다는 점에서 적용 시기의 차이가 있다.\n\n### 인증(Authentication)과 인가(Authorization)\n\n- 인증(Authentiacation) : 해당 사용자가 본인이 맞는지를 **확인**하는 절차\n- 인가(Authorization) : 인증된 사용자가 요청한 자원에 접근 가능한지를 결정하는 절차\n\n> Authentiacation → (인증 성공 후) → Authorization\n> \n\n- Spring Security는 기본적으로 인증 절차를 거친 후, 인가 절차를 진행\n- 인가 과정에서 해당 리소스에 대한 접근 권한이 있는지를 확인하게 된다.\n- Spring Security에서는 이러한 인증과 인가를 위해 Principal을 아이디로, Credential을 비밀번호로 사용하는 **Credential 기반의 인증 방식을** 사용한다.\n    - Principal(접근 주체) : 보호받는 리소스에 접근하는 대상\n    - Credential(비밀전호) : 리소스에 접근하는 대상의 비밀번호","excerpt":"Spring Security란? Spring 기반의 애플리케이션의 보안(인증과 권한, 인가 등)을 담당하는 스프링 하위 프레임워크 인증과 권한에 대한 부분을 Filter 흐름에 따라 처리 Filter는 Dispatcher Servlet 으로 가기전에…","fields":{"slug":"/spring-security-1/"},"frontmatter":{"date":"Jan 04, 2022","title":"SpringSecurity 란?","tags":["Spring Security"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n개인적으로 참고할려고 기록하는 글입니다.\n\n## MSA 구성요소 및 패턴의 유형\n\n- 인프라 구성요소 : 마이크로서비스를 지탱하는 하부구조 인프라를 구축하는데 필요한 구성요소\n- 플랫폼 패턴 : 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패턴\n- 애플리케이션 패턴 : 마이크로서비스 애플리케이션을 구성하는데 필요한 패턴\n\n## 서비스 유형별 대표적인 클라우드 서비스\n\n- `Iaas(Infrastructure as a Service)` :\n  가상 머신, 스토리지, 네트워크 같은 인프라를 필요한 만큼 적시에 제공하는 서비스\n  (예시 : AWS EC2, GCP Compute Engine, Azure VM)\n\n- `CaaS(Container as a Service)` :\n  컨테이너 기반 가상화를 사용해 컨테이너를 업로드, 구성, 실행, 확장, 중지할 수 있는 서비스\n  (예시 : Google Kubernetes Engine, AWS ECS)\n\n- `Paas(Platform as a Service)` : 애플리케이션을 즉시 개발, 실행, 관리할 수 있는 플랫폼 환경 서비스\n  (예시 : Azure Web App, Google App Engine, Heroku, AWS Elastic Beanstalk)\n\n## 개발 지원 환경 DevOps\n\n- `DevOps` : 마이크로서비스를 빌드하고 테스트한 뒤 배포할 수 있게 도와주는 개발 지원 환경\n\n- `CI/CD` - 자동화된 빌드나 배포작업,\n\n  - `CI`는 `지속적 통합(Continuous Integration)` 자동으로 통합 및 테스트하고 그 결과를 기록하는 활동\n  - `CD`는 `지속적 제공(Continuous Delivery)` 및 `지속적 배포(Continouss Deployment)` 실행환경에 내보내는 활동\n  - `지속적 제공`은 빌드된 소스코드의 실행 파일을 실행환경에 반영하기 위해 승인 및 배포 담당자의 허가를 받아야하고\n    배포도 수동으로 처리한다.\n  - `지속적 배포`은 소스코드 저장소(Github)에서 빌드한 소스코드의 실행 파일을 실행 환경 까지 자동으로 배포하는 방식\n    모든 영역을 자동화하는 것에 해당함.\n\n- `Infrastructure as a Code` - 인프라 구성을 마치 프로그래밍하는 것 처럼 처리하고 소수의 인원으로 컨테이너 배포 처리하는 과정\n  (배포 파이프라인 절차를 코드로 완벽히 자동화)\n\n## MSA 주요 아키텍처 패턴\n\n- Spring Cloud + DevOps\n  - Spring Cloud : Spring Boot + Netflix OSS\n\n## 참고한 자료\n\n- [도메인 주도 설계로 시작하는 마이크로서비스 개발](http://www.yes24.com/Product/Goods/98880996)","excerpt":"개인적으로 참고할려고 기록하는 글입니다. MSA 구성요소 및 패턴의 유형 인프라 구성요소 : 마이크로서비스를 지탱하는 하부구조 인프라를 구축하는데 필요한 구성요소 플랫폼 패턴 : 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패…","fields":{"slug":"/msa-related-term/"},"frontmatter":{"date":"Sep 28, 2021","title":"마이크로서비스 아키텍처(MSA) 관련 용어 정리","tags":["MSA","마이크로서비스 아키텍쳐","정리"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n처음에는 Jekyll로 블로그를 만들었는데 생각보다 마음에 안들어서, 검색하다보니 Gatsby를 발견했다.\nGatsby는 `React` 프레임워크를 기반으로 만들었는데 React를 전에 한번 입문해봐서 이걸로 선택했다.\n<br>\n<br>\n처음에는 `npm`으로 node module를 설치해서 환경을 구성했는데. 후반에 가니깐 한번 꼬이니깐 계속 꼬여서\nnpm을 재설치하고 시간을 많이 잡아 먹었다. 그래서 `yarn`으로 다시 패키지 설치하고 하니 잘되더라.\n<br>\n<br>\n# 1. Gatsby 설치\n\n## Gatsby-cli 설치\n패키지 매니저를 통해서 `gatsby-cli`를 설치한다.\n``` sh\n# npm\nnpm install -g gatsby-cli\n```\n```sh\n# yarn\nyarn add gatsby-cli\n```\n\n## 테마 설치\n```sh\ngatsby new [디렉터리 이름] [테마 깃허브 주소]\n```\n디렉터리에 다운받은 테마가 위치된다.\n```sh\ncd [디렉터리 이름]\nyarn start\n```\n\n그후 [localhost:8000](localhost:8000) 를 접속해서 설치한 테마를 맛본다.\n\n# 2. 나만의 블로그로 꾸미기\n## 포스트 위치\n다음 위치에서 블로그 포스팅을 추가할 수 있다.\n\n- `content/blog` : 포스트 파일 위치\n- `content/__about` : 프로필 파일 위치\n\n<br>\n\n포스트 파일은 `.markdown` 또는 `.md`을 사용한다.\n<br>\n\n## 메타데이터\n`gatsby-config.js` 파일이나 `gatsby-meta-config.js`파일에서 \n<br>\n블로그를 설정하는\n여러 요소를 수정할 수 있다.\n원하는 설정으로 수정하면된다.\n\n그 외의 설정은 \n`gatsby-browser.js`, `gatsby-node.js`을 참고\n\n## CSS 파일\n`src/styles` 위치에서 CSS 속성들을 수정할 수 있다.\n\n<br>\n직접 설정을 다하면 글을 한번 작성해봐서 깃허브 저장소나 자신만의 서버에서 배포하면된다.\n\n# 3. SEO 적용\nSEO는 `search engine optimization`로 검색 엔진 최적화, 구글이나 네이버에서 우리 블로그를 찾기 쉽도록 사이트를 개선하는 프로세스이다.\n\n## sitemap.xml 생성\n검색엔진에 검색이 잘 되게 할려면 웹 크롤러가 우리 사이트를 찾아와 크롤링을 하는데, 우리는 이정표를 만들어줘야한다.\n`sitemap.xml`이 이정표 역활을 한다.\n<br>\ngatsby는 `sitemap.xml`을 자동 생성해주는 플러그인이 있다. 추가하자\n<br>\n<br>\n`gastby-config.js`\n```js\n    plugins: [\n        ...\n        'gatsby-plugin-sitemap',\n    ]\n```\nplugins에 추가하면 build 될 때 마다 파일을 생성해준다.\n\n<br>\n그 후 플러그인을 설치하고, gatsby를 실행 한다.\n\n```sh\nyarn add gatsby-plugin-sitemap\ngatsby develop\n```\n\n[http://localhost:8000/sitemap.xml](http://localhost:8000/sitemap.xml)에 접속\n\n```xml\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\" xmlns:mobile=\"http://www.google.com/schemas/sitemap-mobile/1.0\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\">\n    <url>\n    ...\n    </url>\n</urlset>\n```\n위와 같은 xml 형식의 문서가 나오면 성공.\n\n## rss.xml 생성\nrss는 사이트를 방문하지 않아도 그 사이트의 새로운 글이 올라오면 알람을 준다고 생각하면된다.\n그리고 rss를 등록하는것도 검색엔진최적화 작업에 해당된다.\n\n```sh\nyarn add gatsby-plugin-feed\n```\n`sitemap`과 마찬가지로 build 할때마다 새로운 파일을 생성해야 하니 plugins에 추가하자.\n\n`gastby-config.js`\n```js\n    plugins: [\n        ...\n        'gatsby-plugin-feed',\n    ]\n```\n`rss.xml` 이 제대로 생성됬는지 확인하자\n```sh\ngatsby develop\n```\n그 후 [http://localhost:8000/rss.xml](http://localhost:8000/rss.xml)에 접속\n<br>\n`rss.xml` 페이지가 제대로 나온다면 성공.\n\n## robots.txt 생성\n`robots.txt`도 웹 크롤러가 사이트에 접속하면 찾는 파일이므로 만들어준다.\n\n```sh\nyarn add gatsby-plugin-robots-txt\n```\n`gastby-config.js`\n\n```js\nplugins: [\n\t...\n\t{\n      resolve: 'gatsby-plugin-robots-txt',\n      options: {\n        host: 웹사이트경로,\n        sitemap: 웹사이트경로/sitemap.xml',\n        policy: [{\n          userAgent: '*',\n          allow: '/'\n        }]\n      }\n    },\n\t...\n]\n```\n그리고 빌드해서 확인.\n\n```sh\ngatsby develop\n```\n그 후 [http://localhost:8000/robots.txt](http://localhost:8000/robots.txt)에 접속해\n`robots.txt`가 생성됬는지 확인한다.\n\n## 구글 서치 콘솔(GSC) 등록\n[구글등록](https://search.google.com/search-console/about)에서 시작하기를 통해 등록한다.\n우측에 URL 접두어를 선택하고 인증용 html 파일을 다운로드한다.\n다운받은 html 파일은 프로젝트 경로에 복사하고 `package.json`에서 build 스크립트를 작성한다.\n<br>\n`package.json`\n\n```json\n  \"scripts\": {\n        ...\n        \"copy\" : \"cp content/google인증용파일.html public/\",\n        \"build\": \"gatsby build && npm run copy\",\n        ...\n  }\n```\n빌드시 `npm run copy`를 통해 인증 html 파일을 public 경로로 복사해 줄 것이다.\n\n```\nyarn build\ngatsby serve\n```\n를 통해 \"http://localhost:9000/google인증파일.html\" 접속해서 잘 뜨는지 확인한다.\n그리고 sitemaps 메뉴내에 빈칸에 `sitemap.xml` 입력하고 제출한다.\n\n그러면 구글검색엔진에 등록되기까진 몇시간정도 걸리므로 기다리고 검색창에 `site: 블로그주소` 를 입력해서 확인하자.\n\n\n## 네이버 검색 노출\n\n네이버 검색도 구글에 하던것처럼 하면된다.\nhttps://searchadvisor.naver.com/console/board 접속해서 사이트를 등록한다.\n- 좌측 사이드바 메뉴에서 요청 - 사이트맵 제출에서 sitemap.xml의 경로를 입력한다.\n- 요청 - RSS 제출에서도 마찬가지로 경로를 입력한다.\n- 검증 - robots.txt에서 robots.txt 검증 및 수집요청을 한다.\n- 설정 - 수집 주기 설정을 빠르게를 체크한다.\n모든 등록이 끝났으면 몇시간뒤에 검색창에서 `site: 블로그주소`를 입력해서 등록됬는지 확인한다.\n\n## 다음 검색 노출\n다음은 다른 검색엔진보다 매우 간단해서.\nhttps://register.search.daum.net/index.daum에 접속해서 블로그를 등록만하면 끝이다.\n\n\n# 끝으로\n이렇게 간단하게 겟츠비를 통해서 블로그를 만들고 SEO 적용까지 해봤다.\n생략된 부분도 많지만 충분히 참고할 수 있을 것이다.\nReact를 잘 사용하거나 앞으로 사용해야하는 개발자가 블로그를 만들게 된다면\nGatsby로 만들어보는 것을 추천한다. 테마로 만들어도 되지만 자신이 직접 react로 만들어도 좋을것이다.\n<br>\n만약에 블로그를 수정하다가 `npm` 관련 오류가 발생한다면, yarn으로 전환해서 구축하거나,\nnpm 패키지를 재설치 해보자.\n\n\n","excerpt":"처음에는 Jekyll로 블로그를 만들었는데 생각보다 마음에 안들어서, 검색하다보니 Gatsby를 발견했다.\nGatsby는  프레임워크를 기반으로 만들었는데 React를 전에 한번 입문해봐서 이걸로 선택했다.\n\n\n처음에는 으로 node module를 …","fields":{"slug":"/gatsby-blog-start/"},"frontmatter":{"date":"Sep 28, 2021","title":"Gatsby로 블로그를 만들기","tags":["Gatsby","Blog"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n#application.properties\n\n스프링 애플리케이션은 다음 리소스가 주어진 순서대로 고려된다.\n\n1. 명령행 인수\n2. 패키징된 애플리케이션 외부의 `application.properties`\n3. 패키징된 애플리케이션 내부의 `application.properties`\n\napplication-{profile}.properties는 프로필에 관련되지 않은 파일 보다 우선된다.\n\n1. 명령행 인수\n2. 패키징된 애플리케이션 외부의 `application-{profile}.properties`\n3. 패키징된 애플리케이션 외부의 `application.properties`\n4. 패키징된 애플리케이션 내부의 `application-{profile}.properties`\n5. 패키징된 애플리케이션 내부의 `application.properties`\n\n##application.properties 에서 속성 값 사용하기\n속성 외부화를 위해 우리가 만든 application.properties를 사용할려면 `@Value` 어노테이션을 사용해야한다.\n`@Value` 어노테이션은 스프링이 속성을 찾고 해당 속성의 값을 사용하도록 지시한다.\n\n```java\npublic 리턴타입 메소드(@Value(\"${hi}\") int hi) {\n  ...\n}\n```\n\n스프링은 hi라는 이름을 가진 속성을 감지하고 그 값을 사용한다.\n\n또한 `:`을 사용해 기본값을 지정할 수 있다.\n\n```java\npublic 리턴타입 메소드(@Value(\"${hi:10}\") int hi) {\n  ...\n}\n```\n\n만약 `:` 기본값을 지정하면 값을 찾지 못했을 때 10을 기본값으로 사용한다.\n기본값을 정의하지 않고, 해당 속성이 없을 때 `IllegalArgumentException`이 발생한다.\n\n##프로필을 사용한 속성 재정의\n스프링 부트는 프로필을 사용해 추가 구성 파일을 불러와 기존의 application.properties를 전부 대체 또는 일부를 재정의할 수 있다.\n`application-{profile}.properties`를 만들면 된다.\n만약에 `application.properties`에 `hi` 값이 있고, `application-hi.properties`에 `hi`라는 값이 있으면\n`application-hi.properties`의 속성 우선순위가 높기 때문에 대체된다.\n\n##다른 속성 파일로부터 속성 불러오기\n내가 사용하고 싶은 속성 파일을 불러오고자 하면은, `@SpringBootApplication` 어노테이션이 붙은 클래스에\n`@PropertySource` 어노테이션을 추가해 사용할 수 있다.\n\n```java\n@PropertySource(\"classpath:임의의속성파일.properties\")\n@SpringBootApplication\npublic class MySpringApp {\n...\n}\n```\n\n`@PropertySource` 어노테이션은 스프링부트가 시작할 때 추가 속성 파일을 불러와준다.\n해당 어노테이션 대신 밑에 표의 매개변수를 사용하면 스프링 부트가 추가 속성 파일을 불러온다.\n\n| 매개변수                          |                         설명 |\n| :-------------------------------- | ---------------------------: |\n| spring.config.name                |             불러올 파일 목록 |\n| spring.config.location            |             속성 파일의 위치 |\n| spring.config.additional-location | 속성 파일을 불러올 추가 위치 |\n\n위 매개변수를 사용하면, application.properties는 불러오지 않는다.\n모두 검색하는 방법으로는 `--spring.config.name=application,불러올속성파일`을 사용한다.","excerpt":"application.properties 스프링 애플리케이션은 다음 리소스가 주어진 순서대로 고려된다. 명령행 인수 패키징된 애플리케이션 외부의  패키징된 애플리케이션 내부의  application-{profile}.properties는 프로필에 관…","fields":{"slug":"/springboot-application-properties-extern/"},"frontmatter":{"date":"Sep 27, 2021","title":"[SpringBoot] 속성 외부화","tags":["SpringBoot","속성","Properties"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}