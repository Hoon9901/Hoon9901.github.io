{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"# 0. 시작하기 전\n이미지 파일을 실시간으로 감지하고, 스프링 서버로 전송하는 것을 구현하였습니다.\n\n기본적인 구조는 클라이언트-서버 구조를 가지고있습니다\n\n클라이언트는 파일을 생성하고 파일을 감지하여 서버로 전송합니다\n\n서버는 클라이언트로 부터 받은 파일을 어떤 폴더로 저장하는 기능을 수행합니다\n\n# 1. 실시간 파일 감지 프로그램\n\n어떤 프로그램에 의해 어떤 경로에 이미지 파일이 지속적으로 생성된다고 가정하겠습니다.\n\n해당 컴퓨터(이하 클라이언트)에서 자바의 `WatchService`를 이용해 파일을 실시간으로 감지합니다.\n\n이 감지하는 프로그램의 코드를 보겠습니다.\n\n## Main.java\n\n```java\npackage org.example;\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            FileWatch fileWatch = new FileWatch();\n            fileWatch.create();\n            fileWatch.run();\n        } catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n\n}\n```\n\n- `fileWatch` 인스턴스를 생성하고 초기화합니다.\n- 그리고 `create()` 와 `run()` 메소드를 호출하였습니다.\n- try-catch 으로 감싸 예외 처리를 해줬습니다.\n\n\n`main` 메소드 코드를 통해 자세한 프로그램 기능과 역활은 잘 모르겠지만 이 프로그램의 동작 구조를 파악할 수 있습니다.\n\n`create()` 메소드를 통해 어떠한 생성, 초기화 작업을 할것이고. `run()` 메소드를 통해 어떠한 작업을 하는 것을 볼 수 있습니다.\n\n이제부터 FileWatch클래스의 역활과 기능을 자세히 살펴보겠습니다.\n\n## FileWatch.java\n\n```java\npackage org.example;\n\nimport okhttp3.*;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.*;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class FileWatch {\n    private WatchService watchService;\n\n    private Path path;\n\n    private static Integer createdFileCount = 0;\n\n    private final String serverUrl = \"http://localhost:8080/upload\";\n\n    public FileWatch() {}\n\n    public void create() throws IOException {\n\t\t\t\t...\n    }\n\n    public void run() throws Exception {\n\t\t\t\t...\n    }\n\n    void fileSendToServer(String fileName, String currentFilePath){\n\t\t\t\t...\n    }\n\n}\n```\n\nFileWatch는 사용자가 지정한 경로를 실시간으로, 파일 변경에 대해 감지하고 HTTP 통신을 통해 서버로 파일을 전송합니다.\n\n자바에서 제공하는 WatchService 클래스를 멤버로 가지는데 WatchService에 대해 간단하게 알아보겠습니다.\n\n### WatchService란?\n\n자바에는 한 디렉토리(폴더) 내부 파일의 변화를 감지할 수 있는 기능을 제공합니다.\n\n디렉토리안에 있는 파일이 생성, 수정, 삭제되었을 때 이를 감지합니다.\n\n그리고 WatchService는 파일변경 통지 매커니즘으로 알려집니다.\n\n해당 서비스의 동작 순서는 이러합니다.\n\n1. 생성 : WatchService를 초기화\n2. 감시자 지정 : 감지할 경로를 등록하고 어떤 변화를 감시할 것인지를 지정.\n3. 서비스 실행 : \n    디렉토리에 WatchService를 등록한 순간부터 내부 변경이 발생하면 WatchEvent가 발생하고 WatchService는 해당 이벤트 정보를 가진 WatchKey를 생성해 Queue에 넣어집니다. \n    \n    프로그램은 루프를 돌면서 WatchService의 take() 메서드를 호출해 WatchKey가 들어올 때 까지 대기하고 있다가 WatchKey가 큐에 들어오면 WatchKey를 얻어 처리.\n    \n4. 이벤트 처리 : WatchEvent 리스트에서 WatchEvent를 하나씩 꺼내 이벤트 종류와 Path 객체를 얻고 처리.\n5. 이벤트 초기화 : 한번 사용 된 WatchKey는 reset() 메소드로 초기화해야합니다.\n    그 이유는 새로운 WatchEvent가 발생하면 큐에 다시 들어가기 때문입니다\n    초기화에 성공시 true, 감시하는 디렉토리가 삭제됬거나 키가 유효하지 않을 경우 false를 반환\n6. 종료 : \n    WatchKey가 유요하지 않게되면 루프를 빠져나와 WatchService의 close() 메소드를 호출하고 종료\n    \n\n## FileWatch.create()\n\n```java\npublic void create() throws IOException {\n\t\t\t\tScanner sc = new Scanner(System.in);\n        watchService = FileSystems.getDefault().newWatchService();\n\n        System.out.println(\"서버 경로를 입력해주세요(입력안할 시 기본 URL) :\");\n        String tempUrl = sc.nextLine();\n        if (!tempUrl.equals(\"\")) {\n            serverUrl = tempUrl;\n        }\n        System.out.println(serverUrl + \"로 연결합니다\");\n\n        System.out.print(\"경로를 입력해주세요 : \");\n        String filePath = sc.nextLine();\n\n        path = Paths.get(filePath);\n\n        path.register(watchService,\n                StandardWatchEventKinds.ENTRY_CREATE,\n                StandardWatchEventKinds.ENTRY_MODIFY,\n                StandardWatchEventKinds.ENTRY_DELETE,\n                StandardWatchEventKinds.OVERFLOW\n        );    \n}\n```\n\n`create` 메소드에서는 서버 경로를 입력받고 감시할 디렉터리 경로를 입력받습니다.\n\n```java\n       **path.register(watchService,\n                StandardWatchEventKinds.ENTRY_CREATE,\n                StandardWatchEventKinds.ENTRY_MODIFY,\n                StandardWatchEventKinds.ENTRY_DELETE,\n                StandardWatchEventKinds.OVERFLOW\n        );**  \n```\n\n`Path` 객체를 통해 `WatchService`를 등록합니다. `StandardWatchEventKinds`를 지정하여 **생성**, **수정**, **삭제**, 유효 처리에 대한 이벤트를 감지하도록 등록하였습니다.\n\n## FileWatch.run()\n\n```java\npublic void run() throws Exception {\n        String watchPath = path.getParent() + \"/\" + path.getFileName() + \"/\";\n        System.out.println(\"감시하는 경로 : \" + watchPath + \"\\n\");\n\n        while (true) {\n            WatchKey key = watchService.take();\n            List<WatchEvent<?>> watchEvents = key.pollEvents();\n\n            for (WatchEvent<?> event : watchEvents) {\n                WatchEvent.Kind<?> kind = event.kind();\n                Path newFIle = (Path) event.context();\n                Path absolutePath = newFIle.toAbsolutePath();\n\n                if (kind.equals(StandardWatchEventKinds.ENTRY_CREATE)) {\n                    String filepaths = watchPath + newFIle.getFileName().toString();\n                    System.out.println(String.format(\"[%d번] 파일 생성됨 : %s\", ++createdFileCount, newFIle.getFileName()));\n                    fileSendToServer(newFIle.getFileName().toString(),filepaths);\n\n                } else if (kind.equals(StandardWatchEventKinds.ENTRY_MODIFY)) {\n                    System.out.println(\"파일 수정됨 : \" + newFIle.getFileName() + \"\\n\");\n                } else if (kind.equals(StandardWatchEventKinds.ENTRY_DELETE)) {\n                    System.out.println(\"파일 삭제됨 : \" + newFIle.getFileName() + \"\\n\");\n                } else if (kind.equals(StandardWatchEventKinds.OVERFLOW)) {\n                    System.out.println(\"Overflow \\n\");\n                }\n            }\n            if (!key.reset()) {\n                try {\n                    watchService.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n```\n\n`run()` 메소드에서는 파일 감지 이벤트를 조건문으로 생성 시, 수정 시, 각각에 대한 적절한 처리를 해줬습니다.\n\n파일이 생성되면 `fileSendToServer` 메소드로 파일의 이름, 경로를 인자로 넘겨 서버로 전송합니다.\n\n## FileWatch.fileSendToServer(…)\n\n```java\nvoid fileSendToServer(String fileName, String currentFilePath){\n        OkHttpClient client = new OkHttpClient();\n\n        RequestBody requestBody = new MultipartBody.Builder().setType(MultipartBody.FORM)\n                .addFormDataPart(\n                        \"file\", // 파라미터\n                        fileName,\n                        RequestBody.create(MediaType.parse(\"text/csv\"), new File(currentFilePath))\n                ).build();\n        Request request = new Request.Builder()\n                .url(serverUrl)\n                .post(requestBody)\n                .build();\n        System.out.println(String.format(\"파일 경로 : %s\", currentFilePath));\n\n        client.newCall(request).enqueue(new Callback() {\n            @Override\n            public void onFailure(@NotNull Call call, @NotNull IOException e) {\n                System.out.println(\"전송 실패 : \" + call.request().toString());\n                System.out.println(\"에러 내용 : \" + e.getMessage());\n                System.out.println();\n\n            }\n\n            @Override\n            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {\n                System.out.println(\"전송 응답 : \" + response.body().string());\n                System.out.println();\n            }\n        });\n    }\n```\n\n`OkHTTPClient` 라이브러리를 사용해 간단하게 HTTP 통신을 수행합니다.\n\n`RequestBody` 객체로 파일에 대한 형식과, 파라미터, 파일 이름에 대해 설정 합니다.\n\n`Request` 객체를 통해 서버의 경로와 Body에 대한 설정을 하고\n\n`client.newCall()` 메소드를 통해 실질적으로 서버로 HTTP 요청을 전송.\n\n콜백함수를 통해 정상,실패에 대한 처리를 해줬습니다.\n\nFileWatch에 대한 코드 설명은 끝났습니다. 이제부터 파일 통신을 담당하는 스프링 서버를 보겠습니다.\n# 2. 스프링 파일 서버\n\n- build.gradle\n    \n    ```java\n    plugins {\n        id 'org.springframework.boot' version '2.7.0'\n        id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n        id 'java'\n        id 'org.springframework.experimental.aot' version '0.12.0'\n    }\n    \n    group = 'com.hoon'\n    version = '0.0.1-SNAPSHOT'\n    sourceCompatibility = '11'\n    \n    configurations {\n        compileOnly {\n            extendsFrom annotationProcessor\n        }\n    }\n    \n    repositories {\n        maven { url 'https://repo.spring.io/release' }\n        mavenCentral()\n    }\n    \n    dependencies {\n        implementation 'org.springframework.boot:spring-boot-starter-validation'\n        implementation 'org.springframework.boot:spring-boot-starter-web'\n        compileOnly 'org.projectlombok:lombok'\n        annotationProcessor 'org.projectlombok:lombok'\n        testImplementation 'org.springframework.boot:spring-boot-starter-test'\n    }\n    \n    tasks.named('test') {\n        useJUnitPlatform()\n    }\n    \n    tasks.named('bootBuildImage') {\n        builder = 'paketobuildpacks/builder:tiny'\n        environment = ['BP_NATIVE_IMAGE': 'true']\n    }\n    ```\n    \n    자바 버전은 11, 스프링은 2.7.0 버전을 사용하고, 롬복과 유효처리 의존성을 가집니다.\n    \n\n파일 서버는 간단하게 하나의 컨트롤러를 가지고 따로 영속성 처리를 위한 데이터베이스를 가지고 있지 않습니다. 따라서 간단한 패키지 구조를 가집니다.\n\n## FileController.java\n\n```java\n@RestController\n@Slf4j\npublic class FileController {\n    @Value(\"${uploadPath}\")\n    private String FILE_UPLOAD_PATH;\n\n    @PostMapping(value = \"/upload\", consumes = {MediaType.MULTIPART_FORM_DATA_VALUE})\n    public ResponseEntity addFiles(@RequestParam(\"file\") MultipartFile file) {\n        try {\n            saveFile(file);\n        } catch (Exception e) {\n            return new ResponseEntity(e.getMessage(), HttpStatus.BAD_REQUEST);\n        }\n        return new ResponseEntity(\"파일이 업로드 되었습니다\", HttpStatus.OK);\n    }\n\n    public void saveFile(MultipartFile file) throws IOException {\n        String newFileName = UUID.randomUUID() + \"_\" + file.getOriginalFilename();\n        File saveFile = new File(FILE_UPLOAD_PATH, newFileName);\n        log.info(\"새로운 파일 저장! 경로 : \" + saveFile.getAbsolutePath());\n        FileCopyUtils.copy(file.getBytes(), saveFile);\n    }\n}\n```\n\n서버의 `/upload` URL로 `POST` 요청을 처리하는 `addFiles` 메소드가 있습니다. 파일을 저장할때 중복으로 저장할 수 있으므로 UUID를 통해 파일명을 새롭게 수정해줬습니다.\n\n정상적으로 파일이 업로드되었으면 200 Code를 반환하고 그러지 않으면 400 Code를 반환합니다.\n\n`saveFile` 메소드는 요청으로 받은 파일을 서버 지정한 경로로 파일을 저장하는데 해당 저장 경로는 `application.properties`에서 지정합니다.\n\n## application.properties\n\n```java\nspring.servlet.multipart.maxFileSize=10MB\nspring.servlet.multipart.maxRequestSize=10MB\nuploadPath=./images/\n```\n\n# 3. 실행 결과\n\n## FileWatch 프로그램\n\n![실시간으로 파일을 감지하고 서버로 전송하고 정상적으로 응답이 받아오는 모습](1.png)\n\n실시간으로 파일을 감지하고 서버로 전송하고 정상적으로 응답이 받아오는 모습\n\n## FileServer\n\n![클라이언트로 부터 받은 파일을 정상적으로 저장하는 모습](2.png)\n\n클라이언트로 부터 받은 파일을 정상적으로 저장하는 모습\n\n이로써 간단하게 실시간으로 파일을 감지하고 서버로 파일을 전송하는 프로그램을 제작해봤습니다.\n","excerpt":"0. 시작하기 전 이미지 파일을 실시간으로 감지하고, 스프링 서버로 전송하는 것을 구현하였습니다. 기본적인 구조는 클라이언트-서버 구조를 가지고있습니다 클라이언트는 파일을 생성하고 파일을 감지하여 서버로 전송합니다 서버는 클라이언트로 부터 받은 파일…","fields":{"slug":"/filedetect-springfileserver/"},"frontmatter":{"date":"Jul 06, 2022","title":"실시간으로 파일 감지하고 스프링으로 파일 통신을 해보자","tags":["SpringBoot","ToyProject","FileWatch"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# JPA 및 H2 세팅\n\nbuild.gradle 파일에 h2, jpa 의존성을 추가합니다.\n\n```\nimplementation 'org.springframework.boot:spring-boot-starter-data-jpa'\nruntimeOnly 'com.h2database:h2'\n```\n\n그리고 application.properties 파일에 h2 와 jpa 에 대한 설정을 작성합니다.\n\n```\n# h2 설정\nspring.h2.console.enabled=true\nspring.datasource.driver-class-name=org.h2.Driver\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.username=sa\nspring.datasource.password=\n\n# JPA 설정\nspring.jpa.database-platform=org.hibernate.dialect.H2Dialect\nspring.jpa.hibernate.ddl-auto=create-drop\nspring.jpa.properties.hibernate.show_sql=true\nspring.jpa.properties.hibernate.format_sql=true\n\nlogging.level.org.hibernate.type.descriptor.sql=trace\n```\n\n- `spring`\n    - `h2`\n        - `console.enabled` : h2 console 페이지 활성화\n    - `datasource`\n        - `driver-class-name` : 데이터베이스 드라이버를 지정\n        - `url` : 데이터베이스의 경로를 지정합니다 (jdbc:h2:mem → 인메모리)\n        - `username, password` : 데이터베이스 접속하는 유저 정보\n    - `jpa`\n        - `database-platform` : SQL 문법을 지정합니다.\n        - `properties.hibernate.show_sql` : hibernate를 통해 CRUD의 SQL을 로그로 보여줍니다\n        - `properties.hibernate.format_sql` : SQL 문법에 대한 보기좋게 포맷 지정\n        - `hibernate`\n            - `ddl-auto` : 서버를 실행할때 DB 초기화 전략을 지정합니다. (create-drop)\n- `logging`\n    - `level`\n        - `org.hibernate.type.descriptor.sql`: 로깅을 통해 보여지는 SQL문의 내부 값을 출력합니다\n\n# H2 세팅 확인\n\n그리고 서버를 실행해 h2 데이터베이스의 콘솔을 시작합니다.\n\n[http://localhost:8080/h2-console](http://localhost:8080/h2-console) 로 접속을합니다.\n\n![Untitled](1.png)\n\n해당 페이지가 나오게 되는데 Connect 버튼을 눌러 DB에 접속합니다.\n\n![Untitled](2.png)\n\n해당 페이지가 나타나면 정상적으로 h2 세팅이 완료됬습니다.\n\n# JPA 세팅 확인\n\n- JPA 의 동작 원리\n    \n    ![Untitled](3.png)\n    \n\nJPA가 정상적으로 구동하는지 테스트로 코드를 수정합니다.\n\n## User 클래스 수정\n\nUser Entity 클래스을 수정합니다.\n\n```java\n@Entity\n@Getter\n@Setter\n@ToString\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n}\n```\n\n- @Entity : 지정한 클래스를 DB의 테이블과 일대일 매칭\n- @Id : PK 필드를 지정\n- @GenratedValue : PK의 키값 생성 전략 지정 (GenerationType.IDENTITY는 DB에 전략생성 위임)\n\n## UserRepository 수정\n\n이전에는 UserRepository 인터페이스가 상속을 받지 않았고, UserRepositoryImpl 구현체가 있었습니다.\n\n이제는 JPA를 통해서 DB CRUD를 진행하므로 인터페이스를 작성하고 JpaRepository를 상속만 하면됩니다.\n\n```java\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n    Optional<User> findByName(String name);\n}\n\n/* 개발자가 직접 쿼리를 작성한 예시 (참고로 JPQL은 테이블이 아닌 엔티티를 대상으로 쿼리를 발생함)\npublic interface PostsRepository extends JpaRepository<Posts, Long> {\n\n    @Query(\"select p from Posts p order by p.id desc\")\n    List<Posts> findAllDesc();\n*/\n```\n\n- @Query : 어노테이션을 메소드에 지정하여 개발자가 직접 쿼리(JPQL, SQL)를 작성할 수 있습니다. (`nativeQuery = true` 옵션을 통해 SQL 문으로 작성함)\n    \n    해당 어노테이션은 SQL 문법오류를 체크하지 못하고 런타임 에러가 발생하지 못하는 단점 있으므로 이는 Querydsl을 참고해주세요\n    \n\nJPA 의 엄청난 쿼리메소드 기능을 통해 이용자의 이름을 DB에 검색하는 기능을 추가하겠습니다.\n\n인터페이스에 findByName 메소드를 추가합니다. \n\n해당 메소드는 name 변수를 매개변수로 받아서 DB에 해당 name과 동일한 객체를 찾아 반환합니다.\n\n## 서버 실행\n\n이제 서버를 구동하여 JPA 가 정상적으로 작동하는지 확인해보겠습니다.\n\n```java\n2022-01-20 00:55:24.381  INFO 2081 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect\nHibernate: \n    \n    drop table if exists user CASCADE \nHibernate: \n    \n    create table user (\n       id bigint generated by default as identity,\n        name varchar(255),\n        primary key (id)\n    )\n2022-01-20 00:55:24.508  INFO 2081 --- [           main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]\n```\n\n서버를 실행하면 로그에 해당 Hibernate 로그가 발생하는 것을 볼수있습니다. 이것은 application.properties에 작성한 `show_sql` 속성을 통해서 Hibernate의 CRUD가 SQL 구문으로 출력되는 것이고, `ddl-auto` 에 속성을 통해 우리가 지정한 전략(create-drop)을 통해서 DB의 테이블이 초기화되는 부분입니다.\n\n그리고 @Entity 으로 지정한 User 클래스가 테이블로 생성되는 구문 또한 확인할 수 있습니다.\n\n### User 테이블 생성확인\n\n[http://localhost:8080/h2-console](http://localhost:8080/h2-console) 에 접속하여, USER 테이블이 생성됬는지 확인하겠습니다.\n\n![Untitled](4.png)\n\nUSER 테이블이 정상적으로 생성됬습니다. \n\n### DB 저장 확인\n\n이제 API 를 통해 회원가입을 진행하고 해당 값이 정상적으로 저장됬는지 확인하겠습니다.\n\n- 요청 : `POST` [http://localhost:8080/user/new?name=hoon](http://localhost:8080/user/new?name=hoon)\n- 응답 :\n    \n    ```json\n    저장됨 hoon\n    ```\n    \n- 서버 로그\n    \n    ```json\n    Hibernate: \n        select\n            user0_.id as id1_0_,\n            user0_.name as name2_0_ \n        from\n            user user0_ \n        where\n            user0_.name=?\n    2022-01-20 01:09:03.889 TRACE 2081 --- [nio-8080-exec-9] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [hoon]\n    Hibernate: \n        insert \n        into\n            user\n            (id, name) \n        values\n            (null, ?)\n    2022-01-20 01:09:03.909 TRACE 2081 --- [nio-8080-exec-9] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [hoon]\n    ```\n    \n\n해당 요청(회원가입)이 서버 로그에 select, insert 쿼리가 발생하는 것을 확인할 수 있습니다.\n\n이제 h2 콘솔에서 저장된 값을 확인하겠습니다.\n\n![Untitled](5.png)\n\n이제 h2 및 jpa 의 기본적인 설정이 끝났습니다.\n\n추가적인 사용법은 레퍼런스를 참고해주세요\n\n## Reference\n\n[https://dololak.tistory.com/285](https://dololak.tistory.com/285)\n\n[Spring 에서 h2 database 간단 사용법](https://oingdaddy.tistory.com/264) \n\n[https://www.icatpark.com/entry/JPA-기본-Annotation-정리](https://www.icatpark.com/entry/JPA-%EA%B8%B0%EB%B3%B8-Annotation-%EC%A0%95%EB%A6%AC)","excerpt":"JPA 및 H2 세팅 build.gradle 파일에 h2, jpa 의존성을 추가합니다. 그리고 application.properties 파일에 h2 와 jpa 에 대한 설정을 작성합니다.    : h2 console 페이지 활성화   : 데이터베이스…","fields":{"slug":"/spring-how-to-h2-jpa-setting/"},"frontmatter":{"date":"Jul 05, 2022","title":"[SpringBoot] 프로젝트에 H2 및 JPA 세팅법","tags":["SpringBoot"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 컨테이너 라이프사이클\n스프링 컨테이너는 초기화와 종료라는 라이프사이클을 갖는다.\n\n```java\n// 1. 컨테이너 초기화\nAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationConfigApplicationContext(AppContext.class)\n\n// 2. 컨테이너에서 빈 객체를 구해서 사용\nGreeter g = ctx.getBean(\"greeter\", Greeter.class);\nString msg = g.greet(\"스프링\");\nSystem.out.println(mgs);\n\n// 3. 컨테이너 종료\nctx.close();\n```\n\n`AnnotationConfigApplicationContext`의 생성자를 이용해서 컨텍스트를 객체를 생성하는데 이 시점에 스프링 컨테이너를 초기화한다. 스프링 컨테이너는 설정 클래스에서 정보를 읽어와 알맞은 빈 객체를 생성하고 각 빈을 연결하는 작업을 수행한다.\n\n컨테이너 초기화가 완료되면 컨테이너를 사용할 수 있다. 컨테이너를 사용한다는 것은 `getBean()`과 같은 메서드를 이용해서 컨테이너에 보관된 빈 객체를 구한다는 것을 뜻함.\n\n컨테이너 사용이 끝나면 컨테이너를 종료한다. 컨테이너를 종료할 때 사용하는 메서드가 `close()`메서드이다. `close()`메서드는 `AbstractApplicationContext` 클래스에 정의되어 있다. 자바 설정을 사용하는 `AnnotationConfigApplicationContext` 클래스 모두 `AbstractApplicationContext` 클래스를 상속받고 있다.\n\n컨테이너를 초기화하고 종료할 땐 다음의 작업도 함께 수행한다.\n\n- 컨테이너 초기화 → 빈 객체의 생성, 의존 주입, 초기화\n- 컨테이너 종료 → 빈 객체의 소멸\n\n# 빈의 라이프사이클\n스프링 컨테이너는 빈 객체의 라이프사이클을 관리한다. 컨테이너가 괸리하는 빈 객체의 라이프사이클은 다음과 같다.\n\n- 빈 객체의 라이프사이클\n    1. 객체 생성\n    2. 의존 설정 → 의존 자동 주입을 통한 의존 설정 수행 \n    3. 초기화\n    4. 소멸\n\n스프링 컨테이너를 초기화할 때 스프링 컨테이너는 가장 먼저 빈 객체를 생성하고 의존을 설정한다. \n모든 의존 설정이 완료되면 빈 객체의 초기화를 수행한다. 빈 객체를 초기화하기 위해 스프링은 빈 객체의 지정된 메서드를 호출한다. 스프링 컨테이너를 종료하면 스프링 컨테이너는 빈 객체의 소멸을 처리한다. 이때에도 지정한 메서드를 호출한다.","excerpt":"컨테이너 라이프사이클 스프링 컨테이너는 초기화와 종료라는 라이프사이클을 갖는다. 의 생성자를 이용해서 컨텍스트를 객체를 생성하는데 이 시점에 스프링 컨테이너를 초기화한다. 스프링 컨테이너는 설정 클래스에서 정보를 읽어와 알맞은 빈 객체를 생성하고 각…","fields":{"slug":"/spring-bean-lifecycle/"},"frontmatter":{"date":"Jun 28, 2022","title":"[Spring] 스프링 컨테이너와 빈의 라이프사이클","tags":["Spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"컴포넌트 스캔 기능을 사용해서 자동 빈 등록할 때에는 충돌에 주의해야한다.\n\n크게 두가지의 충돌이 발생할 수 있다.\n\n# 1. 빈 이름 충돌\n\n- 두개의 패키지에 같은 이름의 클래스가 존재할 때(모두 `@Component` 가 붙어있음)\n- `ConflictingBeanDefinitionException` 발생함\n    - 클래스를 빈으로 등록할 떄 사용한 빈 이름이 타입이 일치하지 않는(다른 타입) 클래스의 빈 이름과 충돌이 난다는 것\n\n컴포넌트 스캔 과정에서 쉽게 발생할 수 있다. 컴포넌트 스캔과정에서 서로 다른 타입인데 같은 빈 이름을 사용하는 경우가 있다면 **둘 중 하나에 명시적으로 빈 이름을 지정해서 이름 충돌을 피해야한다**.\n\n# 2. 수동 등록한 빈과 충돌\n## 수동 등록한 빈의 경우\n```java\n@Component\npublic class MemberDao {\n\t\t...\n}\n```\n\n- 해당 클래스는 컴포넌트 스캔 대상\n- 자동 등록된 빈의 이름은 “`memberDao`”\n\n다음과 같이 설정 클래스에 직접 `MemberDao` 클래스를 “`memberDao`”라는 이름의 빈으로 등록하면 어떻게 될까?\n\n```java\n@Configuration\n@ComponentScan(basePackages = {\"spring\"})\npublic class AppCtx {\n\t\t@Bean\n\t\tpublic MemberDao memberDao() {\n\t\t\tMemberDao memberDao = new MemberDao();\n\t\t\treturn memberDao;\n\t\t}\n}\n```\n\n스캔할 때 사용하는 빈 이름과 수동 등록한 빈 이름이 같은 경우,\n\n수동 등록한 빈이 우선된다. 즉 `MemberDao` 타입의 빈은 `AppCtx`에서 정의한 한개만 존재.\n\n## 다른 이름의 빈을 수동 등록할 경우\n다음과 같이 다른 이름을 사용한다면?\n\n```java\n@Configuration\n@ComponentScan(basePackages = {\"spring\"})\npublic class AppCtx {\n\t\t@Bean\n\t\tpublic MemberDao memberDao2() {\n\t\t\tMemberDao memberDao = new MemberDao();\n\t\t\treturn memberDao;\n\t\t}\n}\n```\n\n이 경우 스캔 등록한 “`memberDao`” 빈과 수동 등록한 “`memberDao2`” 빈이 모두 존재한다. `MemberDao` 타입의 빈이 두 개가 생성되므로 자동 주입(`@Autowired`)하는 코드는 `@Qualifier` 어노테이션을 사용해서 알맞은 빈을 선택해야한다.","excerpt":"컴포넌트 스캔 기능을 사용해서 자동 빈 등록할 때에는 충돌에 주의해야한다. 크게 두가지의 충돌이 발생할 수 있다. 1. 빈 이름 충돌 두개의 패키지에 같은 이름의 클래스가 존재할 때(모두  가 붙어있음)  발생함 클래스를 빈으로 등록할 떄 사용한 빈…","fields":{"slug":"/component-scan-conflict/"},"frontmatter":{"date":"Jun 27, 2022","title":"[Spring] 컴포넌트 스캔에 따른 충돌처리","tags":["Spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# @Component 어노테이션\n스프링이 검색해서 빈으로 등록할 수 있도록 할려면 클래스에 `@Component` 어노테이션을 붙여야 한다.\n`@Componet` 어노테이션은 해당 클래스를 스캔 대상으로 표시한다.\n\n```java\n**@Component**\npublic class MemberDao {\n\tprivate static long nextId = 0;\n\tprivate Map<String, Member> map = new HashMap<>();\n\t... 생략\n}\n```\n\n`@Component` 어노테이션에 값을 주었는지에 따라 빈으로 등록할 때 사용할 이름이 결정된다.\n- `value` 값을 주지 않았다면 : 클래스 이름의 첫 글자를 소문자로 바꾼 이름을 사용한다.\n    - ex) `MemberDao` 클래스라면,  “`memberDao`”를 빈 이름으로 사용하고\n        \n        `MemberRegisterService` 클래스라면 “`memberRegisterService`”를 빈 이름으로 사용한다.\n        \n# @ComponentScan 어노테이션\n\n`@Component` 어노테이션을 붙인 클래스를 스캔해서 스프링 빈으로 등록하려면 설정 클래스(`@Configuration`)에 `@ComponentScan` 어노테이션을 적용해야 한다.\n\n```java\n@Configuration\n@ComponentScan(basePackages = {\"com.example.sp5chap04.spring\"})\npublic class AppCtx {\n\n    @Bean\n    @Qualifier(\"printer\")\n    public MemberPrinter memberPrinter1() {\n        return new MemberPrinter();\n    }\n\n    @Bean\n    @Qualifier(\"summaryPrinter\")\n    public MemberPrinter memberPrinter2() {\n        return new MemberSummaryPrinter();\n    }\n\n    @Bean\n    public VersionPrinter versionPrinter() {\n        VersionPrinter versionPrinter = new VersionPrinter();\n        versionPrinter.setMajorVersion(5);\n        versionPrinter.setMinorVersion(0);\n        return versionPrinter;\n    }\n}\n```\n\n`@Component` 어노테이션을 붙인 클래스를 검색해서 `Bean`으로 등록해주기 때문에 설정 코드가 줄어들었다.\n\n- `basePackages` 속성 : 해당 속성값을 `{”com.example.sp5chap04.spring”}` 로 해주었다.\n    - 이 속성은 스캔 대상 패키지 목록을 지정한다.\n    - `“com.example.sp5chap04.spring”` 패키지와 그 하위 패키지에 속한 클래스를 스캔 대상으로 지정한다.\n\n## 스캔 대상에서 제외하거나 포함하기\n\n### excludeFilters 속성\n\n`excludeFilters` 속성을 사용하면 스캔할 때 특정 대상을 자동 등록 대상에서 제외할 수 있다.\n\n```java\n@Configuration\n**@ComponentScan(basePackages = {\"com.example.sp5chap04.spring\"}, excludeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = \"spring\\\\.*Dao\"))**\npublic class AppCtxWithExclude {\n\n    @Bean\n    public MemberDao memberDao() {\n        return new MemberDao();\n    }\n    \n    @Bean\n    @Qualifier(\"printer\")\n    public MemberPrinter memberPrinter1() {\n        return new MemberPrinter();\n    }\n\n    @Bean\n    @Qualifier(\"summaryPrinter\")\n    public MemberSummaryPrinter memberPrinter2() {\n        return new MemberSummaryPrinter();\n    }\n\n    @Bean\n    public VersionPrinter versionPrinter() {\n        VersionPrinter versionPrinter = new VersionPrinter();\n        versionPrinter.setMajorVersion(5);\n        versionPrinter.setMinorVersion(0);\n        return versionPrinter;\n    }\n\n}\n```\n\n`@Filter` 어노테이션의 `type` 속성 값으로  `FilterType.REGEX`를 주었다. 이는 정규표현식을 사용해서 제외 대상을 지정한다는 것을 의미한다.\n\n`pattern` 속성은 `FilterType`에 적용할 값을 설정한다. `“spring.”`으로 시작하고 `Dao`로 끝나는 정규표현식을 지정했으므로 `spring.MemberDao` 클래스를 컴포넌트 스캔 대상에서 제외한다.\n\n### FilterType.ASPECTJ\n\n```java\n@ComponentScan(basePackages = {\"com.example.sp5chap04.spring\"}, excludeFilters = @ComponentScan.Filter(type = FilterType.ASPECTJ, pattern = \"spring.*Dao\"))\n```\n\n`FilterType.ASPECTJ`를 필터타입으로 설정할 수 있다. 이 타입을 사용하면 정규표현식 대신 `AspectJ` 패턴을 사용해서 대상을 지정한다.\n\n- `AspectJ` 패턴이 동작하려면 의존 대상에 `aspectjweaver` 모듈을 추가해야한다.\n    \n    ```java\n    \t<dependency>\n    \t\t\t<groupId>org.aspectj</groupId>\n    \t\t\t<artifactId>aspectjweaver</artifactId>\n    \t\t\t<version>1.8.13</version>\n    \t\t</dependency>\n    ```\n    \n\n### FilterType.ANNOTATION\n\n특정 어노테이션을 붙인 타입을 컴포넌트 대상에서 제외할 수도 있다.\n\n```java\n@Retention(RUNTIME)\n@Target(TYPE)\npublic @interface NoProduct {\n}\n\n@Retention(RUNTIME)\n@Target(TYPE)\npublic @interface ManualBean {\n}\n```\n\n이 두 어노테이션을 붙인 클래스를 컴포넌트 스캔 대상에서 제외하려면 다음과 같이 `excludeFilters` 속성을 설정한다.\n\n```java\n@Configuration\n@ComponentScan(basePackages = {\"com.example.sp5chap04.spring\"}, excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {NoProduct.class, ManualBean.class ))\npublic class AppCtxWithExclude {\n\n}\n```\n\n`type` 속성 값으로 `FilterType.ANNOTATION`을 사용하면 `classes` 속성에 필터로 사용할 어노테이션 타입을 값으로 준다.\n\n```java\n@ManualBean\n@Component\npublic class MemberDao {\n\t...\n}\n```\n\n`@ManualBean` 어노테이션을 제외 대상에 추가했으므로 `MemberDao` 클래스를 컴포넌트 스캔 대상에서 제외한다.\n\n## FilterType.ASSIGNABLE_TYPE\n\n특정 타입이나 그 하위 타입을 컴포넌트 스캔 대상에서 제외하려면 `ASSIGNABLE_TYPE`을 `FilterType`으로 사용한다.\n\n```java\n@Configuration\n@ComponentScan(basePackages = {\"com.example.sp5chap04.spring\"}, excludeFilters = @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = MemberDao.class ))\npublic class AppCtxWithExclude {\n```\n\n`classes` 속성에는 제외할 타입 목록을 지정한다. 제외할 타입이 한 개 이상이면 배열 표기를 사용할 수 있다.\n\n## 설정할 필터가 두개 이상\n\n`@ComponentScan`의 `excludeFilters` 속성에 배열을 사용해서 `@Filter` 목록을 전달하면 된다.\n\n```java\n@Configuration\n@CompoenentScan(basePackages = {\"com.example.sp5chap04.spring\"}, excludeFilters = {\n\t@Filter(type = FilterType.ANNOTATION, classes = ManualBean.class), \n\t@Filter(type = FilterType.REGEX, pattern = \"spring2\\\\.*\")\n})\n```","excerpt":"@Component 어노테이션 스프링이 검색해서 빈으로 등록할 수 있도록 할려면 클래스에  어노테이션을 붙여야 한다.\n 어노테이션은 해당 클래스를 스캔 대상으로 표시한다.  어노테이션에 값을 주었는지에 따라 빈으로 등록할 때 사용할 이름이 결정된다.…","fields":{"slug":"/component_scan/"},"frontmatter":{"date":"Jun 24, 2022","title":"[Spring] @Component, @ComponentScan 으로 스캔 대상 지정","tags":["Spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# @Configuration  클래스에서 의존 주입(명시적 주입)을 했는데 자동 주입 대상이면 어떻게 될까?\n\n```java\npublic class MemberInfoPrinter {\n\t...\n\t\n\t**@Autowired // 자동 주입**\n\t@Qualifier(\"printer\")\n\tpublic void setPrinter(MemberPrinter printer){\n\t\tthis.printer = printer;\n\t}\n}\n```\n\nMemberInfoPrinter 클래스의 setPrinter 메소드는 위와 같이 @Autowired 어노테이션이 붙어 있다.\n\n```java\n@Configuration\npublic class AppCtx {\n\t...\n\t\n\t@Bean\n\t@Qualifier(\"printer\")\n\tpublic MemberPrinter memberPrinter1() {\n\t\treturn new MemberPrinter();\n\t}\n\n\t@Bean\n\t@Qualifier(\"summaryPrinter\")\n\tpublic MemberSummaryPrinter memberPrinter2() {\n\t\treturn new MemberSummaryPrinter();\n\t}\n\t\n\t@Bean\n\tpublic MemberList listPrinter() {\n\t\treturn new MemberListPrinter();\n\t}\n\n\t@Bean\n\tpublic MemberInfoPrinter infoPrinter() {\n\t\tMemberInfoPrinter infoPrinter = new MemberInfoPrinter();\n\t\t**infoPrinter.setPrinter(memberPrinter2()); // 세터로 의존 주입**\n\t\treturn infoPrinter;\n\t}\n}\n```\n\n`infoPrinter()` 메소드는 `MemberInfoPrinter` 클래스의 `setPrinter()` 메소드를 호출해서 `memberPrinter2` `Bean`(**이메일과 이름만 출력한다**)을 주입한다.\n\n이 상태에서 Spring 애플리케이션을 실행하고 info 명령어를 실행해보자.\n\n그러면 과연 info 명령어를 실행하였을 때 이메일과 이름만을 출력할까?\n\n### 출력 결과\n\n```java\n명령어를 입력하세요:\nnew a@b.c ABC abc abc\n등록했습니다.\n\n명령어를 입력하세요:\ninfo a@b.c\n**[null] 회원 정보: 아이디=1, 이메일=a@b.c, 이름=ABC, 등록일=2022-06-23**\n```\n\n출력 결과를 보면 회원의 전체 정보를 보여준다. 이는 `memberPrinter2` `Bean`(`MemberSummaryPrinter` 타입 객체)이 아닌 `memberPrinter1` `Bean`을 사용해서 회원 정보를 출력한 것을 의미한다.\n\n즉 설정 클래스(@Configuration)에서 세터 메서드를 통해 의존을 주입해도 해당 세터 메서드에 @Autowired 어노테이션이 붙어있으면 자동 주입을 통해 일치하는 빈을 주입한다.\n\n```java\n\t**@Autowired // 자동 주입**\n\t@Qualifier(\"printer\")\n\tpublic void setPrinter(MemberPrinter printer){ \n\t// SummaryPrinter 타입 Bean이 아닌 MemberPrinter를 주입받는다.\n\t\tthis.printer = printer;\n\t}\n\n```\n\n**따라서 @Autowired 어노테이션을 사용했다면 설정 클래스에서 객체를 주입하기 보다는 스프링이 제공하는 자동 주입을 사용하는 편이 낫다.**\n\n<aside>\n✅ 자동 주입을 하는 코드와 수동으로 주입하는 코드가 섞여 있으면 주입을 제대로 하지 않아서 NPE 예외가 발생했을 때 원인을 찾는데 시간이 걸릴 수 있다. 의존 자동 주입(Autowired)를 일관되게 사용해야 이런 문제가 줄어든다. @Autowired를 사용하고 있다면 일부 자동 주입을 적용하기 어려운 코드를 제외한 나머지 코드는 @Autowird를 사용하자.\n\n</aside>","excerpt":"@Configuration  클래스에서 의존 주입(명시적 주입)을 했는데 자동 주입 대상이면 어떻게 될까? MemberInfoPrinter 클래스의 setPrinter 메소드는 위와 같이 @Autowired 어노테이션이 붙어 있다.  메소드는  클래…","fields":{"slug":"/autowired_and_manual_injection/"},"frontmatter":{"date":"Jun 23, 2022","title":"[Spring] @Autowird 자동 의존 주입과 명시적 의존 주입 간의 관계","tags":["Spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# @Autowired 어노테이션을 이용한 의존 자동 주입\n## 자동 주입 기능을 사용하지 않은 코드 (직접 의존 주입)\n````java\n    @Bean\n    public MemberDao memberDao(){\n        return new MemberDao();\n    }\n    \n    @Bean\n    public ChangePasswordService changePwdSvc() {\n        ChangePasswordService pwdSvc = new ChangePasswordService();\n        **pwdSvc.setMemberDao(memberDao());**\n        return pwdSvc;\n    }\n````\n위 코드에서는 직접 세터 메소드를 통해 의존 주입을 하고있다 <br/>\n자동 주입 기능을 사용하면 스프링이 알아서 의존 객체를 찾아서 주입한다.\n\n```java\n    @Bean\n    public MemberDao memberDao(){\n        return new MemberDao();\n    }\n    \n    @Bean\n    public ChangePasswordService changePwdSvc() {\n        ChangePasswordService pwdSvc = new ChangePasswordService();\n        return pwdSvc;\n    }\n```\n\n자동 주입 기능을 사용하면, 위 코드 처럼 의존 객체를 명시하지 않아도,<br/>\n스프링이 필요한 의존 Bean 객체를 찾아서 주입해준다.\n\n# 자동 주입 기능 사용\n매우 간단하다. 의존을 주입할 대상에 @Autowired 어노테이션을 붙이기만 하면 된다.\n## @Autowired \n\nBean 객체의 메소드에 @Autowired 어노테이션을 붙이면 스프링은 해당 메서드를 호출한다.\n</br> 이때 메서드 파라미터 타입에 해당하는 Bean 객체를 찾아 인자로 주입한다.\n\n```java\n@Bean\npublic MemberDao memberDao(){\n        return new MemberDao();\n        }\n\n\n// 1. 필드 자동 주입\n@Autowired\nprivate MemberDao mebmerDao;\n\n// 2. 메서드 자동 주입\n@Autowired\npublic void setMemberDao(MemberDao memberDao) {\n    this.memberDao = memberDao;\n}\n```\n\n@Autowired 어노테이션을 필드나, 세터 메서드에 붙이면 \n</br> 스프링은 타입이 일치하는 Bean 객체를 찾아서 주입한다.\n\n## 자동 주입 예외 케이스\n### 주입해야할 빈 객체가 없다면?\n```\nError creating bean with name 'memberRegSvc': Unsatisfied dependency expressed through field 'memberDao'; \nnested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.example.sp5chap04.spring.MemberDao' available: expected at least 1 bean which qualifies as autowire candidate\n```\nmemberRegSvc Bean 객체가 생성하는 도중, 의존하는 memberDao 객체를 스프링이 찾이를 못해 `NoSuchBeanDefinitionException` \n</br> 예외가 발생했다.\n\n### 주입해야할 빈이 두개 이상이면?\n```java\n    // MemberPrinter 를 주입받는 세터 메서드\n\t@Autowired\n    public void setMemberPrinter(MemberPrinter printer) {\n        this.printer = printer;\n    }\n    \n    // 동일한 Bean 객체를 생성한다\n    @Bean\n    public MemberPrinter memberPrinter1() {\n        return new MemberPrinter();\n    }\n\n    @Bean\n    public MemberPrinter memberPrinter2() {\n        return new MemberPrinter();\n    }\n```\n해당 코드 처럼, MemberPrinter 타입의 Bean 객체가 2개 정도 만들어진 상태에서는 어떻게 될까?\n\n```\nspringframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.example.sp5chap04.spring.MemberPrinter' available: expected single matching bean but found 2: memberPrinter1,memberPrinter2\n```\n\nMemberPrinter 타입의 빈이 여러개 있어서, 한정할 수 없는데, </br>\n해당 타입 빈이 한개가 아니라, 이름이 memberPrinter1, memberPrinter2 인 두개의 빈을 </br>\n발견 했다는 사실을 알려준다. </br>\n\n## @Qualifier 어노테이션\n자동 주입 가능한 빈이 두 개 이상이면 자동 주입할 빈을 지정하는 방법이 필요할 때 시용한다. <br/>\n@Qualifier 어노테이션을 사용하면 자동 주입 대상 빈을 한정할 수 있다.\n\n```java\n@Configuration\npublic class AppCtx {\n    \n    ...\n    \n    @Bean\n    **@Qualifier(\"printer\")**\n    public MemberPrinter memberPrinter1(){\n        return new MemberPrinter();\n    }\n\n    @Bean\n    public MemberPrinter memberPrinter2() {\n        return new MemberPrinter();\n    }\n}\n```\n위 코드에서 memberPrinter1() 메소드에 \"printer\" 값을 갖는 @Qualifier 어노테이션을 붙였다 <br/>\n이 설정은 해당 Bean의 한정 값으로 \"printer\"를 지정한다.\n\n이렇게 지정한 한정 값은 @Autowired 어노테이션에서 자동 주입할 빈을 한정할 때 사용한다.\n```java\npublic class MemberListPrinter{\n    \n    ...\n    \n\t@Autowired\n\t@Qualifier(\"printer\")\n\tpublic void setMemberPrinter(MemberPrinter printer) {\n\t\tthis.printer = printer;\n\t}\n}\n```\nsetMemberPrinter() 메소드에 @Autowired 어노테이션을 붙였으므로 MemberPrinter 타입의 빈을 자동 주입한다. <br/>\n이떄 @Qualifier 어노테이션 값이 \"printer\" 이므로 한정 값이 \"printer\"인 Bean을 의존 주입 후보로 사용한다.\n\n@Autowired 어노테이션을 필드, 메서드에 모두 적용할 수 있으므로 @Qualifier 어노테이션도 필드, 메소드 모두 적용할 수 있다.","excerpt":"@Autowired 어노테이션을 이용한 의존 자동 주입 자동 주입 기능을 사용하지 않은 코드 (직접 의존 주입) 위 코드에서는 직접 세터 메소드를 통해 의존 주입을 하고있다 \n자동 주입 기능을 사용하면 스프링이 알아서 의존 객체를 찾아서 주입한다. …","fields":{"slug":"/spring_autowired/"},"frontmatter":{"date":"Jun 23, 2022","title":"[Spring] @Autowird 어노테이션을 이용한 의존 자동 주입과 @Qualifier 빈 한정자","tags":["Spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# 주입 대상 객체를 모두 빈 객체로 설정해야 하나?\n주입할 객체가 꼭 스프링 빈이어야 할 필요는 없다.\n\n```java\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppCtxNoMemberPrinterBean {\n      private MemberPrinter printer = new MemberPrinter();\n          ...\n}\n```\n이 설정 코드는 `MemberPrinter`를 빈으로 등록하지 않았다.\n이렇게 해도 정상적으로 작동한다.\n\n객체를 스프링 빈으로 등록할 때와, 하지 않을 떄의 차이점\n- 스프링 컨테이너가 객체를 관리하는지 여부\n- 위 코드와 같이 설정하면 ``MemberPrinter``를 빈으로 등록하지 않으므로 스프링 컨테이너에서 `MemberPrinter`를 구할 수 없다.\n\n```java\n// MemberPrinter를 빈으로 등록하지 않았으므로\n// 아래 코드는 Exception이 발생한다.\nMemberPrinter printer = ctx.getBean(MemberPrinter.class);\n```\n스프링 컨테이너는 자동 주입, 라이프사이클 관리 등 단순 객체 생성 외에 객체 관리를\n\n위해 다양한 기능을 제공하는데  빈으로 등록한 객체에만 적용한다\n\n### 결론\n스프링 컨테이너가 제공하는 관리 기능이 필요없고 \n\ngetBean() 메소드로 구할 필요가 없다면 빈 객체로 꼭 등록해야 하는 것을 아니다\n\n최근에는 의존 자동 주입 기능을 프로젝트 전반에 걸쳐 사용하는 추세이기 때문에\n\n의존 주입 대상은 스프링 빈으로 등록하는 것이 보통이다.# 주입 대상 객체를 모두 빈 객체로 설정해야 하나?\n주입할 객체가 꼭 스프링 빈이어야 할 필요는 없다.","excerpt":"주입 대상 객체를 모두 빈 객체로 설정해야 하나? 주입할 객체가 꼭 스프링 빈이어야 할 필요는 없다. 이 설정 코드는 를 빈으로 등록하지 않았다.\n이렇게 해도 정상적으로 작동한다. 객체를 스프링 빈으로 등록할 때와, 하지 않을 떄의 차이점 스프링 컨…","fields":{"slug":"/injection_object_is_bean/"},"frontmatter":{"date":"Mar 21, 2022","title":"[Spring] 주입 대상 객체를 모두 빈으로 해야하나?","tags":["Spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Spring Cloud - Config Server/Client\n\n![spring cloud config server 구성 아키텍쳐](1.png)\n\nspring cloud config server 구성 아키텍쳐\n\n- Spring Cloud Config Server 의 저장소는\n  - git, vault, aws s3, redis, jdbc 등 과 같은 저장소를 사용할 수 있습니다.\n\n# 스프링 클라우드 Config\n\n- 스프링 클라우드 구성 서버는 애플리케이션의 모든 마이크로서비스가 구성에 의존할 수 있는 서버를 사용해서중앙 집중식 구성을 제공할 수 있습니다.\n\n### 중앙 집중식 구성의 장점 (= 스프링 클라우드 구성 서버의 장점 )\n\n1. 구성이 더 이상 애플리케이션 코드에 패키징되어 배포되지 않는다. 따라서 애플리케이션을 다시 빌드하거나 배포하지 않고 구성을 변경하거나 원래 값으로 환원할 수 있다.\n2. 공통적인 구성을 공유하는 마이크로서비스가 자신의 속성 설정으로 유지/관리하지않고도 동일한 속성들을 공유할 수 있다. 그리고 속성 변경이 필요하면 한 곳에서 한번만 변경해도 모든 마이크로서비스에 적용할 수 있다.\n3. 보안에 민감한 구성 속성은 애플리케이션 코드와는 별도로 암호화하고 유지/관리할 수 있다. 그리고 복호화된 속성 값을 언제든지 애플리케이션에서 사용할 수 있으므로 복호화를 하는 코드가 애플리케이션에 없어도 된다.\n\n### 구성서버 - 자동 속성 갱신\n\n![spring actuator 를 통한 속성 자동 리프레시](2.png)\n\nspring actuator 를 통한 속성 자동 리프레시\n\n구성 서버를 중앙 속성 서버로 두고, 스프링 Actuator 와, cloud bus, RabbitMQ 를 통해\n\n해당 이미지 처럼 개발자가 속성을 새롭게 수정하였으면, WebHook (/actuator/bus-refresh) 경로로 요청을 보내 변경된 속성을 갱신하고, 운영중인 서버로 부터 설정을 업데이트 하라고 요청을 할 수 있습니다.\n\n## 구성 서버\n\nconfig server 를 구성서버라고 부르겠습니다.\n\n스프링 구성 서버를 제작하고, 설정을 받는 것을 해보겠습니다\n\n### 구성 서버 설정\n- build.gradle\n```groovy\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.cloud:spring-cloud-config-server:3.1.0'\n\n    implementation 'org.springframework.vault:spring-vault-core:2.3.2'\n\n    implementation 'org.springframework.boot:spring-boot-starter-actuator:2.6.3'\n```\n해당 의존성을 추가합나디.\n\n- Main 클래스\n\n```java\n@SpringBootApplication\n**@EnableConfigServer**\npublic class VaultdemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(VaultdemoApplication.class, args);\n    }\n\n}\n```\n\n**EnableConfigServer** 어노테이션을 달아서, 구성서버 자동 설정합니다.\n\n- application.yml\n\n```yaml\nserver:\n  port: 8888\n\nspring:\n  profiles:\n    active:\n      - native\n      - vault\n\n  cloud:\n    config:\n      server:\n        native:\n          search-locations: file:./config\n        vault:\n          kv-version: 1\n          authentication: token\n          token: \"vault token\"\n          host: localhost\n          scheme: http\n          port: 8200\n```\n\n위 설정들은 구성 서버 자체 구성에 필요한 속성들입니다.\n\n구성 서버가 클라이언트(개발 서버[config가 필요한 곳])에 제공하는 config 는 git, vault, native 등(서버 파일 시스템)의 repository (저장소)에서 가져옵니다.\n\n현재 서버의 속성을 보시면은 구성을 가져올 저장소가 두 곳 인것을 볼 수 있습니다.\n\n- native : 프로젝트 경로의 config 디렉터리 내부 파일(설정 파일들이 위치)\n- vault : vault 의 secret 경로\n  - 클라이언트에서 vault의 token 을 발급 하지 않고 속성만 받을 수 있게 구성 서버에서 token을 지정하였습니다.\n\n### 구성 서버 native 속성 파일\n\n- /config/test.yml\n\n```bash\nmessage:\n  hello: \"hi\"\n```\n\nnative 저장소에 있는 설정 파일입니다.\n\n### 구성 서버 vault secret\n\n```bash\n❯ curl -X GET http://localhost:8200/v1/test-app/dev -H \"X-Vault-Token: token값\" | jq\n\n{\n  \"request_id\": \"0f62463e-fec4-7c60-7103-d6baf2fc04c7\",\n  \"lease_id\": \"\",\n  \"renewable\": false,\n  \"lease_duration\": 3153600000,\n  \"data\": {\n    **\"hello\": \"world\",\n    \"this\": \"is\"**\n  },\n  \"wrap_info\": null,\n  \"warnings\": null,\n  \"auth\": null\n}\n```\n\n- test-app/dev [key , value 저장소]\n  - hello : world\n  - this : is\n\n### 구성 서버 테스트 하기\n\n![Untitled](3.png)\n\n- localhost:8888 : 구성 서버의 호스트 이름과 포트\n- application : 애플리케이션 이름(spring.application.name)\n- default : 활성화된 스프링 프로파일(E.g. production) (14.2.2)\n- master : Git 라벨/분기(생략 가능, master가 기본값)\n\n- test 속성 받기\n  ```bash\n  ❯ curl -X GET http://localhost:8888/test/default | jq\n    \"name\": \"test\",\n    \"profiles\": [\n      \"default\"\n    ],\n    \"label\": null,\n    \"version\": null,\n    \"state\": null,\n    \"propertySources\": [\n      {\n        **\"name\": \"file:config/test.yml\",**\n        \"source\": {\n          **\"message.hello\": \"hi\"**\n        }\n      }\n    ]\n  }\n  ```\n  [localhost:8888](http://localhost:8888)/test/default 로 요청을 보냈습니다.\n  test.yml 속성을 받아온것을 볼 수 있습니다.\n\n# 레퍼런스\n\n[https://cloud.spring.io/spring-cloud-config/reference/html/#\\_environment_repository](https://cloud.spring.io/spring-cloud-config/reference/html/#_environment_repository)\n\n[https://lejewk.github.io/vault-get-started/](https://lejewk.github.io/vault-get-started/)\n\n[https://www.vaultproject.io/docs/commands](https://www.vaultproject.io/docs/commands)\n\n[https://wonit.tistory.com/502](https://wonit.tistory.com/502)\n\n[https://velog.io/@ha0kim/스프링-인-액션-14.리액티브-데이터-퍼시스턴스](https://velog.io/@ha0kim/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9D%B8-%EC%95%A1%EC%85%98-14.%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%EC%8A%A4)\n","excerpt":"Spring Cloud - Config Server/Client  spring cloud config server 구성 아키텍쳐 Spring Cloud Config Server 의 저장소는 git, vault, aws s3, redis, jdbc 등…","fields":{"slug":"/spring-cloud-config/"},"frontmatter":{"date":"Mar 07, 2022","title":"Spring Cloud Config Server/Client","tags":["SpringBoot","Cloud","Config"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n![토이프로젝트에서 WebHook 알림 발생](1.png)\n\n이 글에서는 스프링부트에서 디스코드 WebHook을 사용하여, 어떠한 이벤트 요청이 오면, 알림을 알려주는 것을 해보겠습니다.\n\n# WebHook 이란?\n\n![Untitled](2.png)\n\nWebHook은 웹페이지 또는 웹앱에서 발생하는 특정 행동(이벤트)들을 커스텀 Callback 형식으로 반환해주는 방법입니다.\n\n일반적인 API(Polling)는 클라이언트가 서버를 호출하는 방식인데, WebHook의 경우 서버에서 특정 이벤트가 발생했을 때 클라이언트를 호출하는 방식이며 역방향 API라고도 부르기합니다.\n\n따라서 서버에서 이벤트가 발생했을 때 클라이언트의 어느 URL로 데이터를 보내는 것을 (Callback URL) 구현하는 것을 생각하신다면 WebHook을 사용하시면 좋을 것 같습니다.\n\n# 디스코드 채널 WebHook 설정\n\n![Untitled](3.png)\n\n특정 채널에 웹훅을 만들기 위해서는, 채널 편집에 들어가서, 연동을 들어가시고, 웹후크를 생성해줍니다.\n\n아바타 사진과, 이름 등과 같은 설정을 하시고 **웹후크 URL 복사**를 눌러줍니다.\n\n해당 웹후크 URL 로 서버에서 어떤 데이터를 담아 요청을 보내면 되겠습니다.\n\n# WebHook 어떻게 사용하는가?\n\n[디스코드 공식문서 Create Message](https://discord.com/developers/docs/resources/channel#create-message) 를 보시면 Json 형식의 데이터로 POST 요청을 웹후크 URL을 보내면 됩니다.\n\n```json\n{\n  \"content\": \"Hello, World!\",\n  \"tts\": false,\n  \"embeds\": [{\n    \"title\": \"Hello, Embed!\",\n    \"description\": \"This is an embedded message.\"\n  }]\n}\n```\n\n공식 문서의 예제 코드에서는 위 Json형식의 데이터를 보내게 되는데요 한번 API를 요청을 보내보면\n\n![Untitled](4.png)\n\n이런식으로 오는것을 볼 수 있습니다. 자세한 사용은 공식문서를 참고하셔서 어떤 데이터를 어떻게 보낼지 찾아보시면 되겠습니다.\n\n# 스프링부트에서 WebHook 메시지 보내기\n\n서버에서 어떠한 요청(이벤트)이 발생하게 되면은, 디스코드로 메세지를 보내는 것을 구현하겠습니다.\n\n## 프로젝트 패키지 구성\n\n- controller\n    - `EventController`\n- discord\n    - config\n        - `BotConfiguration`\n    - service\n        - `WebHookService`\n\n## application-discord.yml\n\n```java\ndiscord:\n  webhookURL: \"웹후크URL\"\n```\n\n웹후크 URL을 지정합니다\n\n## BotConfiguration 클래스\n\n```java\n@Configuration\npublic class BotConfiguration {\n\n    @Bean\n    public WebHookService webHookService(){\n        return new WebHookService();\n    }\n}\n```\n\nConfiguration을 통해서 WebHookService Bean을 생성하겠습니다.\n\n## WebHookService 클래스\n\n```java\npublic class WebHookService {\n\n    @Value(\"${discord.webhookURL}\")\n    private  String url;\n\n    public void callEvent(){\n        JSONObject data = new JSONObject();\n\n        data.put(\"content\", \"[알림] 이벤트가 발생하였습니다\");\n\n        send(data);\n    }\n\n    private void send(JSONObject object){\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n\n        RestTemplate restTemplate = new RestTemplate();\n        HttpEntity<String> entity = new HttpEntity<>(object.toString(), headers);\n        restTemplate.postForObject(url, entity, String.class);\n    }\n}\n```\n\n서비스 클래스에서 `callEvent` 메소드가 실행되면 `JSON` 객체를 생성하고, `content` Key에 `value`로 알림을 보낼 메세지 내용을 작성했습니다.\n\n그리고 `send` 메소드에 파라미터로 `JSON` 객체를 담고 해당 메소드를 실행합니다.\n\n`send` 메소드에서는 `RestTemplate` 스프링 객체를 통해서,Json 객체를 HTTP Body에 담고 `POST` 요청을 웹후크 URL로 보내게됩니다.\n\n## EventController 클래스\n\n```java\n@Controller\n@RequiredArgsConstructor\n@RequestMapping(\"/api/event\")\npublic class EventController {\n\n    private final WebHookService webHookService;\n    \n    @PostMapping(\"\")\n    public String postEvent(){\n\t\t\t\t// 이벤트 처리 ...\n        webHookService.callEvent();\n        return \"이벤트 발생!\";\n    }\n```\n\n컨트롤러에서는 `/api/event` Post 요청이 들어오면 orderEvent 그 요청을 처리하게 되는데요. \n\n내부에선 이벤트 비즈니스 로직을 수행하고, 웹후크를 통해서 알림을 보냅니다.\n\n## 서버 구동\n\n이젠 스프링부트 서버를 구동하여, API를 요청해서 알림 메세지를 받아보겠습니다.\n\n![Untitled](5.png)\n\n```java\n❯ curl -X POST \"http://localhost:8080/api/event\"\n```\n\n해당 URL 로 POST 요청을 보내게되면은, 디스코드에 알림이 발생하는 것을 볼 수 있습니다!\n\n이런식으로 디스코드 WebHook을 사용하시면되고, 메세지를 커스텀하여, 웹후크 메세지를 보내시면 되겠습니다.\n\n# 레퍼런스\n\n[https://discord.com/developers/docs/resources/channel#create-message](https://discord.com/developers/docs/resources/channel#create-message)\n\n[https://leffept.tistory.com/329](https://leffept.tistory.com/329)\n","excerpt":"이 글에서는 스프링부트에서 디스코드 WebHook을 사용하여, 어떠한 이벤트 요청이 오면, 알림을 알려주는 것을 해보겠습니다. WebHook 이란?  WebHook은 웹페이지 또는 웹앱에서 발생하는 특정 행동(이벤트)들을 커스텀 Callback 형식…","fields":{"slug":"/springboot-disord-webhook/"},"frontmatter":{"date":"Feb 19, 2022","title":"[SpringBoot] 디스코드 WebHook으로 알림 보내기","tags":["SpringBoot","Discord","WebHook"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"![Untitled](1.png)\n\n쇼핑물에서 이용자의 구매이력을 조회 시, N+1 문제가 발생해 성능저하가 일어나는 상황에서\n간단한 해결법으로 성능 향상을 이루는 법을 알아보겠습니다.\n\n## N+1 문제란?\n\n연관 관계에서 발생하는 이슈로 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 되는 문제\n\n## 엔티티 연관관계\n\n- 주문 엔티티\n    \n    ```java\n    @Entity\n    @Table(name = \"orders\")\n    @Getter\n    @Setter\n    public class Order {\n    \n        @Id\n        @GeneratedValue(strategy = GenerationType.IDENTITY)\n        @Column(name = \"order_id\")\n        private Long id;\n    \n        @ManyToOne(fetch = FetchType.LAZY)\n        @JoinColumn(name = \"member_id\")\n        private Member member;\n    \n        private LocalDateTime orderDate;\n    \n        @Enumerated(EnumType.STRING)\n        private OrderStatus orderStatus;\n    \n        @OneToMany(mappedBy = \"order\", cascade = CascadeType.ALL\n                , orphanRemoval = true, fetch = FetchType.LAZY) \n        private List<OrderItem> orderItems = new ArrayList<>();\n    ```\n    \n    한 주문(`order`)에는 사용자가 주문한 여러개의 상품들(`orderItems`)에 대해 `@OneToMany` 연관관계를 적용했습니다.\n    \n- 주문 상품 엔티티\n    \n    ```java\n    @Entity\n    @Getter\n    @Setter\n    public class OrderItem  {\n    \n        @Id\n        @GeneratedValue(strategy = GenerationType.IDENTITY)\n        @Column(name = \"order_item_id\")\n        private Long id;\n    \n        @ManyToOne(fetch = FetchType.LAZY)\n        @JoinColumn(name = \"item_id\")\n        private Item item;\n    \n        @ManyToOne(fetch = FetchType.LAZY)\n        @JoinColumn(name = \"order_id\")\n        private Order order;\n    \n        private int orderPrice; // 주문가\n        private int count;      // 수량\n    ```\n    \n    주문 상품(`orderItem`)은 하나의 주문(`order`)에 대해 종속(`@ManyToOne`)되있습니다.\n    \n    그리고 상품들에 대한 정보를 가지고있습니다 (여러개의 상품들(주문) → 하나의 상품(진열))\n    \n\n간단하게 정리하자면 \n\n- 주문에는 여러개의 주문 상품들이 들어있습니다.\n- 주문 상품은 하나의 주문에 종속되어 있습니다.\n- 주문 상품은 하나의 상품에 종속되어 있습니다 (실질적인 상품에 대한 정보들)\n- 1 주문 → N 주문 상품\n\n## getOrderList 메소드\n\nN+1 문제가 일어나게 되는 원인인 사용자의 주문이력을 반환하는 메소드입니다.\n\n```java\npublic Page<OrderHistoryDto> getOrderList(String email, Pageable pageable) {\n        List<Order> orders = orderRepository.findOrders(email, pageable);\n        Long totalCount = orderRepository.countOrder(email);\n\n        List<OrderHistoryDto> orderHistoryDtos = new ArrayList<>();\n\n        for (Order order : orders) {\n            OrderHistoryDto orderHistoryDto = OrderHistoryDto.of(order);\n            List<OrderItem> orderItems = order.getOrderItems(); // 문제가 일어나는 부분\n            for (OrderItem orderItem : orderItems) {\n                ItemImg itemImg = itemImgRepository.findByItemIdAndRepImgYn(orderItem.getItem().getId(), \"Y\");\n                OrderItemDto orderItemDto = OrderItemDto.of(orderItem, itemImg.getImgUrl());\n                orderHistoryDto.addOrderItemDto(orderItemDto);\n            }\n\n            orderHistoryDtos.add(orderHistoryDto);\n        }\n        return new PageImpl<OrderHistoryDto>(orderHistoryDtos, pageable, totalCount);\n    }\n```\n\n해당 로직을 보시면은 반복문을 순회하면서 `order.getOrderItems()`를 호출할 때마다 조회 쿼리문이 추가적으로 실행되고 있습니다.\n\n`orders` 리스트(사용자의 주문건들)의 사이즈 만큼 쿼리문이 실행됩니다. 만약 `orders`의 사이즈가 100이었다면 100번의 쿼리문이 더 실행되는 것입니다. 현재는 `order_id` 에 하나의 주문 번호가 조건으로 설정되는 것을 볼수있습니다.\n\n```java\nHibernate: \n    select\n        orderitems0_.order_id as order_id9_5_0_,\n        orderitems0_.order_item_id as order_it1_5_0_,\n        orderitems0_.order_item_id as order_it1_5_1_,\n        orderitems0_.create_time as create_t2_5_1_,\n        orderitems0_.update_time as update_t3_5_1_,\n        orderitems0_.created_by as created_4_5_1_,\n        orderitems0_.modified_by as modified5_5_1_,\n        orderitems0_.count as count6_5_1_,\n        orderitems0_.item_id as item_id8_5_1_,\n        orderitems0_.order_id as order_id9_5_1_,\n        orderitems0_.order_price as order_pr7_5_1_ \n    from\n        order_item orderitems0_ \n    where   // 문제의 부분\n        orderitems0_.order_id=?\n```\n\n만약 `orders`의 주문 아이디를 `“where order_id in (id1, id2, id3, ... )”` 이런식으로 `in` 쿼리로 한번에 조회할 수 있다면 100개가 실행될 쿼리를 하나의 쿼리로 조회할 수 있습니다.\n\n### 무엇이 문제인가\n\n- 하나의 주문을 조회하는 쿼리를 호출한다\n- 주문을 조회할때 주문상품들을 조회하는 쿼리가 하나의 주문을 조회하는 만큼 호출된다.\n\n## batch-size 로 해결하기\n\n- application.properties 설정 추가하기\n    \n    ```java\n    spring.jpa.properties.hibernate.default_batch_fetch_size=1000\n    ```\n\n`batch-size` 옵션은 연관된 하위 엔티티를 로딩할 때 상위 엔티티 ID를 지정한 숫자만큼 `in` 쿼리로 로딩합니다. \n\n예로 들어 `batch-size:1000`으로 되어있으면, 상위 엔티티인 `order`의 id 1000개를 `in` 쿼리로 `orderItem`를 조회하게 됩니다.\n\n해당 옵션을 추가한 후 다시 구매 이력을 조회하면 반복문에서 `order.getOrderItems()` 최초 실행할 때 로그를 보겠습니다.\n\n- 2건의 주문이력을 요청할때\n```java\nHibernate: \n    select\n        orderitems0_.order_id as order_id9_5_1_,\n        orderitems0_.order_item_id as order_it1_5_1_,\n        orderitems0_.order_item_id as order_it1_5_0_,\n        orderitems0_.create_time as create_t2_5_0_,\n        orderitems0_.update_time as update_t3_5_0_,\n        orderitems0_.created_by as created_4_5_0_,\n        orderitems0_.modified_by as modified5_5_0_,\n        orderitems0_.count as count6_5_0_,\n        orderitems0_.item_id as item_id8_5_0_,\n        orderitems0_.order_id as order_id9_5_0_,\n        orderitems0_.order_price as order_pr7_5_0_ \n    from\n        order_item orderitems0_ \n    where\n        orderitems0_.order_id in (\n            ?, ?\n        )\n```\n\n해당 로그를 보시면은 조건절에 in 쿼리문이 실행되는 것을 볼 수 있습니다.\n\n이렇게 간단한 설정을 통해 in 쿼리문으로 조회하도록 성능 이슈를 해결했습니다\nJPA에서 N+1 을 해결하는 방법들은 여러개 이니 batch_size는 연관관계에서 데이터 사이즈를 정확하게 알고 있을 때 조심해서 사용하시면 됩니다.\n\n### Reference\n\n[스프링 부트 쇼핑몰 프로젝트 with JPA](http://www.yes24.com/Product/Goods/103453774)\n\n[Spring Batch JPA에서 N+1 문제 해결](https://jojoldu.tistory.com/414)","excerpt":"쇼핑물에서 이용자의 구매이력을 조회 시, N+1 문제가 발생해 성능저하가 일어나는 상황에서\n간단한 해결법으로 성능 향상을 이루는 법을 알아보겠습니다. N+1 문제란? 연관 관계에서 발생하는 이슈로 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데…","fields":{"slug":"/spring-jpa-N+1-problem/"},"frontmatter":{"date":"Jan 28, 2022","title":"[Spring JPA] 쇼핑물 주문이력 조회 시 N+1 문제 해결하기","tags":["Spring JPA"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# 1. 회원가입 API 작성\n\n## SecurityUtil 클래스\n\n간단한 유틸리티 메소드를 만들기 위해 `SecurityUtil` 클래스를 util 패키지에 생성하겠습니다.\n\n```java\npublic class SecurityUtil {\n\n   private static final Logger logger = LoggerFactory.getLogger(SecurityUtil.class);\n\n   private SecurityUtil() {\n   }\n\n   public static Optional<String> getCurrentUsername() {\n      final Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n\n      if (authentication == null) {\n         logger.debug(\"Security Context에 인증 정보가 없습니다.\");\n         return Optional.empty();\n      }\n\n      String username = null;\n      if (authentication.getPrincipal() instanceof UserDetails) {\n         UserDetails springSecurityUser = (UserDetails) authentication.getPrincipal();\n         username = springSecurityUser.getUsername();\n      } else if (authentication.getPrincipal() instanceof String) {\n         username = (String) authentication.getPrincipal();\n      }\n\n      return Optional.ofNullable(username);\n   }\n```\n\n`getCurrentUsername` 메소드의 역활은 SecurityContext의 Authentication 객체를 이용해 `username`을 리턴해주는 간단한 유틸성 메소드입니다. \n\n`SecurityContext`에 Authenticaion 객체가 저장되는 시점은 JwtFilter의 `doFilter`메소드에서 Request가 들어올때 SecurityContext에 Authenticaion 객체를 저장해서 사용하게 됩니다.\n\n## UserService 클래스\n\n회원가입, 유저 정보 조회등의 메소드를 만들기 위해 UserService 클래스를 생성하겠습니다.\n\n```java\n@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    private final PasswordEncoder passwordEncoder;\n\n    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {\n        this.userRepository = userRepository;\n        this.passwordEncoder = passwordEncoder;\n    }\n\n@Transactional\n    public User signup(UserDto userDto) {\n        if (userRepository.findOneWithAuthoritiesByUsername(userDto.getUsername()).orElse(null) != null) {\n            throw new RuntimeException(\"이미 가입되어 있는 유저입니다.\");\n        }\n\n        Authority authority = Authority.builder()\n                .authorityName(\"ROLE_USER\")\n                .build();\n\n        User user = User.builder()\n                .username(userDto.getUsername())\n                .password(passwordEncoder.encode(userDto.getPassword()))\n                .nickname(userDto.getNickname())\n                .authorities(Collections.singleton(authority))\n                .activated(true)\n                .build();\n\n        return userRepository.save(user);\n    }\n\n    @Transactional(readOnly = true)\n    public Optional<User> getUserWithAuthorities(String username) {\n        return userRepository.findOneWithAuthoritiesByUsername(username);\n    }\n\n    @Transactional(readOnly = true)\n    public Optional<User> getMyUserWithAuthorities() {\n        return SecurityUtil.getCurrentUsername().flatMap(userRepository::findOneWithAuthoritiesByUsername);\n    }\n}\n```\n\nUserService 클래스는 `UserRepository`, `PasswordEncoder`를 주입받습니다.\n\n`singup` 메소드는 username이 DB에 존재하지 않으면 Authority와 User 정보를 생성해서 UserRepository의 `save`메소드를 통해 DB에 정보를 저장합니다. \n\n여기서 **중요한 점**은 `singup` 메소드를 통해 가입한 회원은 USER ROLE을 가지고 있고 `data.sql` 에서 자동 생성되는 admin 계정은 USER, ADMIN ROLE을 가지고 있습니다 이 차이를 통해 권한검증 부분을 테스트 하겠습니다.\n\n그리고 유저 권한정보를 가져오는 메소드가 2개 있습니다.\n\n`getUserWithAuthorities`는 username을 기준으로 정보를 가져오고\n\n`getMyUserWithAuthorities`는 SecurityContext에 저장된 username의 정보만 가져옵니다.\n\n이 두가지 메소드의 허용권한을 다르게 해서 권한검증에 대한 부분을 테스트하겠습니다.\n\n# 2. 권한 검증\n\n## UserController 클래스\n\n`UserService`의 메소드들을 호출할 `UserController` 클래스를 생성하겠습니다.\n\n```java\n@RestController\n@RequestMapping(\"/api\")\npublic class UserController {\n    private final UserService userService;\n\n    public UserController(UserService userService) {\n        this.userService = userService;\n    }\n\n    @PostMapping(\"/signup\")\n    public ResponseEntity<User> signup(@Valid @RequestBody UserDto userDto) {\n        return ResponseEntity.ok(userService.signup(userDto));\n    }\n\n    @GetMapping(\"/user\")\n    @PreAuthorize(\"hasAnyRole('USER','ADMIN')\")\n    public ResponseEntity<User> getMyUserInfo(HttpServletRequest request) {\n        return ResponseEntity.ok(userService.getMyUserWithAuthorities().get());\n    }\n\n    @GetMapping(\"/user/{username}\")\n    @PreAuthorize(\"hasAnyRole('ADMIN')\")\n    public ResponseEntity<User> getUserInfo(@PathVariable String username) {\n        return ResponseEntity.ok(userService.getUserWithAuthorities(username).get());\n    }\n}\n```\n\n- `@PreAuthorize`\n    - 해당 메서드가 호출되기 이전에 권한을 검사한다\n- `hasAnyRole([role1, role2])`\n    - 현재 사용자의 권한이 파라미터의 권한 중 일치하는 것이 있는 경우 `true` 를 리턴\n\n`sinup` 메소드는 UserDto를 매개변수로 받아서 UserService의 `singup` 메소드를 호출합니다.\n\n`getMyUserInfo` 메소드는 `@PreAuthorize`를 통해서 USER, ADMIN 두가지 권한 모두 허용했고\n\n`getUserInfo` 메소드는 ADMIN 권한만 호출할 수 있도록 설정했습니다 그리고 `UserService`에서 만들었던 username 매개변수를 기준으로 유저 정보와 권한 정보를 리턴하는 API가 되겠습니다. \n\n# 3. Response 시 DTO를 통해서만 받기\n\n## 기존 문제점\n\n추가적으로 지금까지 로직을 보시면 사용자 요청에 대해 응답을 Entity 그대로 전달하기 때문에 문제가있습니다.  문제점을 보기위해 Entity를 통해 반환을 하게 되면 어떤 결과를 나오는지 보겠습니다.\n\n- Response - `POST` /api/signup\n\n```json\n{\n    \"userId\": 3,\n    \"username\": \"hoon\",\n    \"password\": \"$2a$10$PZhLrJzS9YQX1.M5.ezMhu/VFAbtSiYLU.ExF3qzlBrrk7bHPyzdm\",\n    \"nickname\": \"nick\",\n    \"activated\": true,\n    \"authorities\": [\n        {\n            \"authorityName\": \"ROLE_USER\"\n        }\n    ]\n}\n```\n\n해당 응답 결과처럼, 보시면은 중요한 정보들이 그대로 반환이 됩니다 그 이유는 `UserService`의 회원가입 로직을 처리하는 메소드가 User Entity 그대로 반환해주기 때문에 사용자 측에서는 해당 결과를 받게됩니다.\n\n보안적인 측면에서도 안좋은 방식이므로 DTO를 통해 응답하도록 코드를 수정하겠습니다.\n\n## 해결법\n\n### AuthorityDto 클래스 생성\n\n권한정보에 대한 DTO 클래스를 작성하겠습니다.\n\n```java\n@Getter\n@Setter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class AuthorityDto {\n    private String authorityName;\n}\n```\n\n### UserDto 클래스 수정\n\n아래와 같이 권한 정보에 대한 `authorityDtoSet` 필드를 추가하고 `from` 메소드를 추가합니다.\n\n```java\nprivate Set<AuthorityDto> authorityDtoSet;\n\n    public static UserDto from(User user) {\n        if(user == null) return null;\n\n        return UserDto.builder()\n                .username(user.getUsername())\n                .nickname(user.getNickname())\n                .authorityDtoSet(user.getAuthorities().stream()\n                        .map(authority -> AuthorityDto.builder().authorityName(authority.getAuthorityName()).build())\n                        .collect(Collectors.toSet()))\n                .build();\n    }\n```\n\n`from` 메소드는 `User` 객체를 매개변수로 받아서 해당 객체가 `null`이 아니면, 해당 객체를 `UserDto`로 생성해서 반환합니다.\n\n### UserService 클래스 수정\n\n`User`로 반환하던 이전 메소드들을 `UserDto`로 반환하도록 수정하겠습니다. (굵은 글씨를 봐주세요)\n\n```java\n@Transactional\n    public **UserDto** signup(UserDto userDto) {\n        if (userRepository.findOneWithAuthoritiesByUsername(userDto.getUsername()).orElse(null) != null) {\n            throw new RuntimeException(\"이미 가입되어 있는 유저입니다.\");\n        }\n\n        Authority authority = Authority.builder()\n                .authorityName(\"ROLE_USER\")\n                .build();\n\n        User user = User.builder()\n                .username(userDto.getUsername())\n                .password(passwordEncoder.encode(userDto.getPassword()))\n                .nickname(userDto.getNickname())\n                .authorities(Collections.singleton(authority))\n                .activated(true)\n                .build();\n\n        return **UserDto.from**(userRepository.save(user));\n    }\n\n    @Transactional(readOnly = true)\n    public **UserDto** getUserWithAuthorities(String username) {\n        return **UserDto.from**(userRepository.findOneWithAuthoritiesByUsername(username)**.orElse(null))**;\n    }\n\n    @Transactional(readOnly = true)\n    public **UserDto** getMyUserWithAuthorities() {\n        return **UserDto.from**(SecurityUtil.getCurrentUsername().flatMap(userRepository::findOneWithAuthoritiesByUsername)**.orElse(null))**;\n    }\n```\n\n회원가입 로직을 처리하는 `signup` 메소드는 기존 소스 그대로에서 `UserDto.from` 을 통해 `User`를 Dto로 생성해서 반환합니다.\n\n나머지 두개의 권한 정보을 반환하는 메소드도 `UserDto`로 반환하도록 수정합니다.\n\n기존에는 `Optional`을 통해서 `null` 예외처리를 해줬지만, 이젠 `null` 값이 들어오면 해당 값 그대로 리턴합니다.\n\n### UserController 클래스 수정\n\n요청에 대해 `User`로 반환하던 이전 메소드들을 `UserDto`로 반환하도록 수정하겠습니다.\n\n```java\n@PostMapping(\"/signup\")\n    public ResponseEntity<**UserDto**> signup(@Valid @RequestBody UserDto userDto) {\n        return ResponseEntity.ok(userService.signup(userDto));\n    }\n\n    @GetMapping(\"/user\")\n    @PreAuthorize(\"hasAnyRole('USER','ADMIN')\")\n    public ResponseEntity<**UserDto**> getMyUserInfo(HttpServletRequest request) {\n        return ResponseEntity.ok(userService.getMyUserWithAuthorities());\n    }\n\n    @GetMapping(\"/user/{username}\")\n    @PreAuthorize(\"hasAnyRole('ADMIN')\")\n    public ResponseEntity<**UserDto**> getUserInfo(@PathVariable String username) {\n        return ResponseEntity.ok(userService.getUserWithAuthorities(username));\n    }\n```\n\n기존과 비슷하게 반환하는 객체를 `UserDto`로 변경해줍니다.\n\nAPI 요청에 대해 `Entity`을 반환하는것이 아닌 `Dto`를 반환하는 코드로 변경을 완료했습니다.\n\n# 4. 회원가입 API 테스트\n\n이제 우리가 만든 3개의 API를 Postman, H2 Console를 이용해 테스트해보겠습니다.\n\n## 회원가입 요청\n\nURL : [http://localhost:8080/api/signup](http://localhost:8080/api/signup) 경로로 `POST` 요청을 보냅니다.\n\n![Untitled](5-1.png)\n\n- Response\n    \n    ```json\n    {\n        \"username\": \"hoon\",\n        \"nickname\": \"nick\",\n        \"authorityDtoSet\": [\n            {\n                \"authorityName\": \"ROLE_USER\"\n            }\n        ]\n    }\n    ```\n    \n\n회원가입 API에 대한 응답이 정상적으로 반환됬습니다 이제 가입된 유저정보를 H2 Console 에서 확인해보겠습니다.\n\n### H2 Console\n\n<img src=\"5-2.png\" width=\"300\" height=\"500\"/>\n\n추가한 유저 정보가 잘 등록된것을 볼수있습니다.\n\n이제 권한이 다른 두 계정(admin, uesr)을 가지고 두 개의 API를 테스트해보겠습니다.\n\n## 권한 API 테스트\n\n먼저 ADMIN 권한만 허용했던 API를 테스트하겠습니다.\n\nURL : [http://localhost:8080/api/user/hoon](http://localhost:8080/api/user/hoon) 경로로 GET 요청을 합니다.\n\n- Response - `GET` /api/user/hoon\n    \n    ![Untitled](5-3.png)\n    \n\n401 상태가 반환된것을 볼수있습니다.\n\n### JWT Token 가져오기\n\nADMIN 계정을 로그인해서 token을 가져오겠습니다,\n\nURL : [http://localhost:8080/api/authenticate](http://localhost:8080/api/authenticate) 경로에 POST 요청을 보냅니다.\n\n- Response - `POST` /api/authenticate\n    \n    ```json\n    {\n        \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImF1dGgiOiJST0xFX0FETUlOLFJPTEVfVVNFUiIsImV4cCI6MTY0MjE2NTU3N30.UyNbN-cX82pIRHOMKWTjnDSTLX-TWzER3otxNaKKTxeB9egSL2gp8FMzr5wznIFRXEyBdU-1cFMcKnQerBjiGg\"\n    }\n    ```\n    \n\n그리고 해당 어드민 유저의 토큰을 HTTP Headers에 `Authorization : Bearer {jwt_token}` 형식으로 담고 다시 권한 API 경로로 GET 요청을 보냅니다.\n\n### ADMIN 권한 테스트\n\n- Response - `GET` /api/user/hoon\n    \n    ```json\n    {\n        \"username\": \"hoon\",\n        \"nickname\": \"nick\",\n        \"authorityDtoSet\": [\n            {\n                \"authorityName\": \"ROLE_USER\"\n            }\n        ]\n    }\n    ```\n    \n\n/api/user/hoon 경로는 `ROLE_ADMIN` 권한을 가진 유저만 접근할 수 있는데. 정상적으로 응답이 된것을 확인할수있습니다.\n\n### USER 권한 테스트\n\n이번에는 hoon 계정의 토큰으로 이 API를 재호출 해보도록 하겠습니다.\n\n기존에 로그인 API를 hoon 계정으로 요청하고, 토큰을 발급받습니다.\n\n- Response - `POST` /api/authenticate\n    \n    ```json\n    {\n        \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJob29uIiwiYXV0aCI6IlJPTEVfVVNFUiIsImV4cCI6MTY0MjE2NjA1N30.UMN19s9OGrX10qcO6tgET91rggoatwtfutr6L2iuL4da67vF7vR_4D1zXOKb4_0pCVtamREhGsDm_Y-iMImBPg\"\n    }\n    ```\n    \n\nhoon 계정으로 POST 요청을 했고 해당 토큰을 이용해서 다시 API 를 호출하겠습니다.\n\n- Response - `GET` /api/user/hoon\n    \n    ```json\n    {\n        \"timestamp\": \"2022-01-13T13:15:29.386+00:00\",\n        \"status\": 403,\n        \"error\": \"Forbidden\",\n        \"path\": \"/api/user/hoon\"\n    }\n    ```\n    \n\nhoon 계정의 토큰으로 요청을 해보면 `403 Foribidden` 에러가 반환된 것을 볼수있습니다.\n\n해당 403 Forbidden 에러는 저희가 작성한 `JwtAccessDeniedHandler`에 의해 발생됬습니다.\n\n이번에는 USER권한을 허용해줬던 API를 hoon 계정의 토큰으로 호출해보겠습니다.\n\n- Response - `GET` /api/user\n    \n    ```json\n    {\n        \"username\": \"hoon\",\n        \"nickname\": \"nick\",\n        \"authorityDtoSet\": [\n            {\n                \"authorityName\": \"ROLE_USER\"\n            }\n        ]\n    }\n    ```\n    \n\nhoon 계정으로 발급받은 토큰으로 이 API 는 잘 호출되는 것을 볼수있습니다.\n\n이제 해당 강의에서 준비한 JWT Tutorial의 모든 부분이 완료됬습니다. 읽어주셔서 감사합니다😊\n\n# Reference\n\n[https://gaemi606.tistory.com/entry/Spring-Boot-Spring-Security-PreAuthorize사용하기](https://gaemi606.tistory.com/entry/Spring-Boot-Spring-Security-PreAuthorize%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)\n\n[https://steemit.com/kr-dev/@igna84/spring-security-preauthorize-postauthorize](https://steemit.com/kr-dev/@igna84/spring-security-preauthorize-postauthorize)","excerpt":"1. 회원가입 API 작성 SecurityUtil 클래스 간단한 유틸리티 메소드를 만들기 위해  클래스를 util 패키지에 생성하겠습니다.  메소드의 역활은 SecurityContext의 Authentication 객체를 이용해 을 리턴해주는 간단한…","fields":{"slug":"/springboot-jwt-tutorial5/"},"frontmatter":{"date":"Jan 14, 2022","title":"SpringBoot JWT 튜토리얼 - 5장 회원가입, 권한검증 [최종]","tags":["SpringBoot","JWT","튜토리얼"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# 1. DTO 클래스 생성\n\n## LoginDto 클래스\n\n외부와의 통신에 사용할 DTO 패키지 및 클래스를 생성합니다.\n\n```java\n@Getter\n@Setter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class LoginDto {\n\n    @NotNull\n    @Size(min = 3, max = 50)\n    private String username;\n\n    @NotNull\n    @Size(min = 3, max = 100)\n    private String password;\n}\n```\n\nLombok 어노테이션(Get, Set 등)이 추가되었고 @Valid 관련 어노테이션을 추가했습니다.\n\n로그인 할 이용자의 아이디, 비밀번호를 담을 username, password 필드를 가집니다.\n\n## TokenDto 클래스\n\nToken 정보를 Response 할때 사용할 TokenDto를 만들겠습니다.\n\n```java\n@Getter\n@Setter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class TokenDto {\n\n    private String token;\n}\n```\n\n## UserDto 클래스\n\n회원가입시에 사용할 UserDto 클래스도 미리 만들어주겠습니다.\n\n```java\n@Getter\n@Setter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class UserDto {\n\n    @NotNull\n    @Size(min = 3, max = 50)\n    private String username;\n\n    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)\n    @NotNull\n    @Size(min = 3, max = 100)\n    private String password;\n\n    @NotNull\n    @Size(min = 3, max = 50)\n    private String nickname;\n}\n```\n\n# 2. Repository 관련 코드 작성\n\n이제 Repository들을 만들어주기 위해 repository 패키지를 생성합니다.\n\n## UserRepository 인터페이스\n\n이전에 만들었던 User 엔티티에 매핑되는 UserRepository 인터페이스를 만들겠습니다.\n\n```java\npublic interface UserRepository extends JpaRepository<User, Long> {\n    @EntityGraph(attributePaths = \"authorities\")\n    Optional<User> findOneWithAuthoritiesByUsername(String username);\n}\n```\n\n- `EntityGraph` : 쿼리가 수행될때 Lazy 조회가 아니고 Eager조회로 authorities 정보를 같이가져옵니다.\n    - Lazy, Eager : 지연로딩(lazy), 즉시로딩(eager) 연관관계의 데이터를 어떻게 가져올지 (fetch)\n\n`JpaRepository`를 `extends` 하면 `findAll`, `save` 등의 메소드를 기본적으로 사용할 수 있습니다.\n\n`findOneWithAuthoritiesByUsername` 메소드는 username을 기준으로 User 정보를 가져올때 권한 정보도 같이 가져오게됩니다.\n\n# 3. 로그인 API, 관련 로직 생성\n\n## CustomUserDetailsService 클래스\n\nSpring Security에서 중요한 부분중 하나인 UserDetailsService를 구현한 CustomUserDetailsService 클래스를 생성하겠습니다. \n\n먼저 service 패키지를 만들어고 해당 패키지에 클래스를 생성합니다.\n\n```java\n@Component(\"userDetailsService\")\npublic class CustomUserDetailsService implements UserDetailsService {\n    private final UserRepository userRepository;\n\n    public CustomUserDetailsService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    @Override\n    @Transactional\n    public UserDetails loadUserByUsername(final String username) {\n        return userRepository.findOneWithAuthoritiesByUsername(username)\n                .map(user -> createUser(username, user))\n                .orElseThrow(() -> new UsernameNotFoundException(username + \" -> 데이터베이스에서 찾을 수 없습니다.\"));\n    }\n\n    private org.springframework.security.core.userdetails.User createUser(String username, User user) {\n        if (!user.isActivated()) {\n            throw new RuntimeException(username + \" -> 활성화되어 있지 않습니다.\");\n        }\n        List<GrantedAuthority> grantedAuthorities = user.getAuthorities().stream()\n                .map(authority -> new SimpleGrantedAuthority(authority.getAuthorityName()))\n                .collect(Collectors.toList());\n        return new org.springframework.security.core.userdetails.User(user.getUsername(),\n                user.getPassword(),\n                grantedAuthorities);\n    }\n}\n```\n\n`UserDetailsService`를 `implements`하고 `UserRepository`를 주입받습니다. `loadUserByUsername` 메소드를 오버라이드해서 로그인시에 DB에서 유저정보와 권한정보를 가져오게됩니다.\n\n해당 정보를 기반으로 해서 `userdetails.user` 객체를 생성해서 리턴합니다.\n\n## AuthController 클래스\n\n로그인 API를 추가하기 위해서 AuthController 클래스를 만들겠습니다.\n\n```java\n@RestController\n@RequestMapping(\"/api\")\npublic class AuthController {\n    private final TokenProvider tokenProvider;\n    private final AuthenticationManagerBuilder authenticationManagerBuilder;\n\n    public AuthController(TokenProvider tokenProvider, AuthenticationManagerBuilder authenticationManagerBuilder) {\n        this.tokenProvider = tokenProvider;\n        this.authenticationManagerBuilder = authenticationManagerBuilder;\n    }\n\n    @PostMapping(\"/authenticate\")\n    public ResponseEntity<TokenDto> authorize(@Valid @RequestBody LoginDto loginDto) {\n\n        UsernamePasswordAuthenticationToken authenticationToken =\n                new UsernamePasswordAuthenticationToken(loginDto.getUsername(), loginDto.getPassword());\n\n        Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken);\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n\n        String jwt = tokenProvider.createToken(authentication);\n\n        HttpHeaders httpHeaders = new HttpHeaders();\n        httpHeaders.add(JwtFilter.AUTHORIZATION_HEADER, \"Bearer \" + jwt);\n\n        return new ResponseEntity<>(new TokenDto(jwt), httpHeaders, HttpStatus.OK);\n    }\n}\n```\n\n이전에 만들었던 `TokenProvider`, `AuthenticationManagerBuilder` 를 주입받습니다.\n\n로그인 API 경로는 `/api/authenticate` 경로이고 `POST` 요청을 받습니다.\n\n### authorize 메소드\n\n`authorize` 메소드는 LoginDto의 username, password를 매개변수로 받고 이를 이용해 `UsernamePasswordAuthenticationToken`을 생성합니다.\n\nauthenticationToken을 이용해서 Authentication 객체를 생성하려고 `authenticate` 메소드가 실행이될 때 `CustomUserDetailsService` 클래스의 `loadUserByUsername` 메소드가 실행됩니다.\n\n이 결과값을 이용해서 Authenticaion 객체를 생성하고 이를 SecurityContext 에 저장하고 Authenticaion 객체를 `createToken` 메소드를 통해서 JWT Token 을 생성합니다.\n\nJWT Token 을 Response Header에 넣어주고 TokenDto를 이용해서 Response Body에도 넣어서 리턴하게 됩니다.\n\n# 4. 로그인 API 테스트\n\n자 이제 로그인 API 를 포스트맨으로 테스트해보겠습니다.\n\n## 로그인 요청\n\n [http://localhost:8080/api/authenticate](http://localhost:8080/api/authenticate) 경로로 아래와 같이 `POST` 요청을 보냅니다.\n\n![Untitled](4-1.png)\n\nadmin 계정 정보는 data.sql의 insert문이 서버가 시작될때 자동실행되어 DB에 저장된 상태입니다.\n\n- 405 HTTP 상태 코드가 발생하면?\n    - Server Log\n    \n    ```json\n    2022-01-12 18:35:18.364 DEBUG 5197 --- [nio-8080-exec-1] com.example.jwttutorial.jwt.JwtFilter    : 유효한 JWT 토큰이 없습니다, uri: /api/authenticate\n    2022-01-12 18:35:18.373  WARN 5197 --- [nio-8080-exec-1] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'text/plain;charset=UTF-8' not supported]\n    2022-01-12 18:35:18.374 DEBUG 5197 --- [nio-8080-exec-1] com.example.jwttutorial.jwt.JwtFilter    : 유효한 JWT 토큰이 없습니다, uri: /error\n    ```\n    \n    - Response\n    \n    ```json\n    {\n        \"timestamp\": \"2022-01-12T09:33:18.957+00:00\",\n        \"status\": 415,\n        \"error\": \"Unsupported Media Type\",\n        \"path\": \"/api/authenticate\"\n    }\n    ```\n    \n    위와 같이 응답이 반환되면 POST 요청을 보낼때 `JSON` 형식으로 보내시면됩니다.\n    \n\n## 정상 응답\n\n정상적으로 요청이 응답된다면 서버에선 해당 sql문 query 내용이 로그로 나타납니다\n\n```sql\nHibernate: \n    select\n        user0_.user_id as user_id1_1_0_,\n        authority2_.authority_name as authorit1_0_1_,\n        user0_.activated as activate2_1_0_,\n        user0_.nickname as nickname3_1_0_,\n        user0_.password as password4_1_0_,\n        user0_.username as username5_1_0_,\n        authoritie1_.user_id as user_id1_2_0__,\n        authoritie1_.authority_name as authorit2_2_0__ \n    from\n        user user0_ \n    left outer join\n        user_authority authoritie1_ \n            on user0_.user_id=authoritie1_.user_id \n    left outer join\n        authority authority2_ \n            on authoritie1_.authority_name=authority2_.authority_name \n    where\n        user0_.username=?\n```\n\n그리고 Repsonse 내용으로 아래와 같이 Token이 정상적으로 리턴됩니다.\n\n```json\n{\n    \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImF1dGgiOiJST0xFX0FETUlOLFJPTEVfVVNFUiIsImV4cCI6MTY0MjA2NjU2NH0.QLtuqh874mipMl-h0cO6p4Jf430RGf2uBArr5nWcnmnvG6YqVo0qFXGxEwbPHD9u7J4Zl1GIL0YuWQTXWdUYHA\"\n}\n```\n\n이제 DTO 클래스, Repository, 로그인 API의 개발이 완료되었습니다. \n\n디음 편에서는 회원가입 API를 만들고 회원가입한 유저와 admin 관리자의 권한 검증을 구성하겠습니다.\n\n- Postman의 유용한 기능\n\n![Untitled](4-2.png)\n\n위와 같이 Tests 탭에서 Response의 데이터를 전역변수에 저장해서 다른 Request에서도 사용할 수 있습니다.\n\n# Reference\n\n[Spring Docs - JpaRepository](https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html)","excerpt":"1. DTO 클래스 생성 LoginDto 클래스 외부와의 통신에 사용할 DTO 패키지 및 클래스를 생성합니다. Lombok 어노테이션(Get, Set 등)이 추가되었고 @Valid 관련 어노테이션을 추가했습니다. 로그인 할 이용자의 아이디, 비밀번호…","fields":{"slug":"/springboot-jwt-tutorial4/"},"frontmatter":{"date":"Jan 13, 2022","title":"SpringBoot JWT 튜토리얼 - 4장 DTO,Repository,로그인 구현","tags":["SpringBoot","JWT","튜토리얼"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# 1. JWT 설정추가\n\napplication.yml 파일을 열고, jwt 설정을 추가하겠습니다.\n\n```yaml\njwt:\n  header: Authorization\n  #HS512 알고리즘을 사용할 것이기 때문에 512bit, 즉 64byte 이상의 secret key를 사용해야 한다.\n  #echo 'silvernine-tech-spring-boot-jwt-tutorial-secret-silvernine-tech-spring-boot-jwt-tutorial-secret'|base64\n  secret: c2lsdmVybmluZS10ZWNoLXNwcmluZy1ib290LWp3dC10dXRvcmlhbC1zZWNyZXQtc2lsdmVybmluZS10ZWNoLXNwcmluZy1ib290LWp3dC10dXRvcmlhbC1zZWNyZXQK\n  token-validity-in-seconds: 86400\n```\n\n- header : JWT를 검증하는데 필요한 정보\n- secret : HS512 알고리즘을 사용할 것이기 때문에 512bit, 즉 64byte 이상의 secret key를 사용해야 한다\n    - 위 예제에서는 Secret Key 를 Base64 로 인코딩한 값임.\n- token-validity-in-seconds : 토큰의 만료시간을 지정함 (단위는 초)\n\n이제 build.gradle 파일로 가서 JWT 관련 라이브러리를 추가합니다.\n\n```yaml\nimplementation group: 'io.jsonwebtoken', name: 'jjwt-api', version: '0.11.2'\nruntimeOnly group: 'io.jsonwebtoken', name: 'jjwt-impl', version: '0.11.2'\nruntimeOnly group: 'io.jsonwebtoken', name: 'jjwt-jackson', version: '0.11.2'\n```\n\n그 후 그래들을 다시 불러와, 프로젝트에 의존성을 설치해줍니다. \n\nJWT 개발을 위한 준비는 완료되었고 이제 JWT 코드를 개발하겠습니다.\n\n# 2. JWT 관련 코드 작성\n\n## TokenProvider 클래스\n\njwt 패키지를 생성하고, 토큰의 생성과 토큰의 유효성 검증등을 담당할 Token Provider 를 만들겠습니다.\n\n```java\n@Component\npublic class TokenProvider implements InitializingBean {\n\n    private final Logger logger = LoggerFactory.getLogger(TokenProvider.class);\n\n    private static final String AUTHORITIES_KEY = \"auth\";\n\n    private final String secret;\n    private final long tokenValidityInMilliseconds;\n\n    private Key key;\n\n    public TokenProvider(\n            @Value(\"${jwt.secret}\") String secret,\n            @Value(\"${jwt.token-validity-in-seconds}\") long tokenValidityInSeconds) {\n        this.secret = secret;\n        this.tokenValidityInMilliseconds = tokenValidityInSeconds * 1000;\n    }\n\n    @Override\n    public void afterPropertiesSet() {\n        byte[] keyBytes = Decoders.BASE64.decode(secret);\n        this.key = Keys.hmacShaKeyFor(keyBytes);\n    }\n}\n```\n\n`InitializingBean`  인터페이스를 구현하여, `afterPropertiesSet` 메소드를 Override 한 이유는\n\nBean이 생성이 되고, 의존성 주입을 받은 후에 secret 값을 Base64 Decode 해서 key 변수에 할당합니다.\n\n### createToken 메소드\n\nAuthentication 객체의 권한정보를 이용해서 토큰을 생성하는 createToken 메소드를 추가합니다.\n\n```java\npublic String createToken(Authentication authentication) {\n      String authorities = authentication.getAuthorities().stream()\n         .map(GrantedAuthority::getAuthority)\n         .collect(Collectors.joining(\",\"));\n\n      long now = (new Date()).getTime();\n      Date validity = new Date(now + this.tokenValidityInMilliseconds);\n\n      return Jwts.builder()\n         .setSubject(authentication.getName())\n         .claim(AUTHORITIES_KEY, authorities)\n         .signWith(key, SignatureAlgorithm.HS512)\n         .setExpiration(validity)\n         .compact();\n   }\n```\n\nauthenticaion 객체를 받아서 권한 설정을 하고, application.yml 에서 설정했던 토큰 만료시간을 설정하고 토큰을 생성합니다.\n\n### getAuthenticaion 메소드\n\ntoken을 매개변수로 받아서, 토큰에 담긴 정보를 이용해 Authenticaion 객체를 리턴하는 메소드를 작성합니다.\n\n```java\npublic Authentication getAuthentication(String token) {\n      Claims claims = Jwts\n              .parserBuilder()\n              .setSigningKey(key)\n              .build()\n              .parseClaimsJws(token)\n              .getBody();\n\n      Collection<? extends GrantedAuthority> authorities =\n         Arrays.stream(claims.get(AUTHORITIES_KEY).toString().split(\",\"))\n            .map(SimpleGrantedAuthority::new)\n            .collect(Collectors.toList());\n\n      User principal = new User(claims.getSubject(), \"\", authorities);\n\n      return new UsernamePasswordAuthenticationToken(principal, token, authorities);\n   }\n```\n\ntoken으로 클레임을 만들고, 클레임에서 권한정보를 받아서 유저 객체를 만들어서 최종적으로 Authenticaion 객체를 리턴합니다.\n\n- Claims : JWT 의 속성정보, java 에서 Claims 는 Json map 형식의 인터페이스임\n\n### validateToken 메소드\n\ntoken을 매개변수로 받아서, 토큰의 유효성 검증을 수행하는 validateToken 메소드를 작성합니다.\n\n```java\npublic boolean validateToken(String token) {\n      try {\n         Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);\n         return true;\n      } catch (io.jsonwebtoken.security.SecurityException | MalformedJwtException e) {\n         logger.info(\"잘못된 JWT 서명입니다.\");\n      } catch (ExpiredJwtException e) {\n         logger.info(\"만료된 JWT 토큰입니다.\");\n      } catch (UnsupportedJwtException e) {\n         logger.info(\"지원되지 않는 JWT 토큰입니다.\");\n      } catch (IllegalArgumentException e) {\n         logger.info(\"JWT 토큰이 잘못되었습니다.\");\n      }\n      return false;\n   }\n```\n\n토큰을 파싱하고, 발생하는 예외들을 캐치하여, 문제가 있음면 false, 정상이면 true를 리턴합니다.\n\n## JwtFilter 클래스\n\nJWT를 위한 커스텀 필터를 만들기 위해 JwtFilter 클래스를 생성합니다.\n\n```java\npublic class JwtFilter extends GenericFilterBean {\n\n    private static final Logger logger = LoggerFactory.getLogger(JwtFilter.class);\n\n    public static final String AUTHORIZATION_HEADER = \"Authorization\";\n\n    private TokenProvider tokenProvider;\n\n    public JwtFilter(TokenProvider tokenProvider) {\n        this.tokenProvider = tokenProvider;\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)\n            throws IOException, ServletException {\n        \n    }\n}\n```\n\n- doFilter : JWT 토큰의 인증정보를 현재 실행중인 SecurityContext 에 저장하는 역활\n\nGenericFilterBean을 상속받아 doFilter 메소드를 Override.\n\n실제 필터링 로직은 doFilter 내부에 작성합니다.\n\n### resolveToken 메소드\n\nRequest Header 에서 토큰정보를 가져오기 위한, resolveToken 메소드를 추가합니다.\n\n```java\nprivate String resolveToken(HttpServletRequest request) {\n      String bearerToken = request.getHeader(AUTHORIZATION_HEADER);\n      if (StringUtils.hasText(bearerToken) && bearerToken.startsWith(\"Bearer \")) {\n         return bearerToken.substring(7);\n      }\n      return null;\n   }\n```\n\n### doFilter 메소드 내부 로직\n\n doFilter의 내부 로직을 작성하겠습니다.\n\n```clike\nHttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;\n      String jwt = resolveToken(httpServletRequest);\n      String requestURI = httpServletRequest.getRequestURI();\n\n      if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {\n         Authentication authentication = tokenProvider.getAuthentication(jwt);\n         SecurityContextHolder.getContext().setAuthentication(authentication);\n         logger.debug(\"Security Context에 '{}' 인증 정보를 저장했습니다, uri: {}\", authentication.getName(), requestURI);\n      } else {\n         logger.debug(\"유효한 JWT 토큰이 없습니다, uri: {}\", requestURI);\n      }\n\n      filterChain.doFilter(servletRequest, servletResponse);\n```\n\nresolveToken 을 통해 토큰을 받아와서 유효성 검증을 하고 토큰이 정상적이면 Authenticaion 객체를 받아와서 \n\nSecurityContext 에 저장합니다.\n\n## JwtSecurityConfig 클래스\n\nTokenProvider, JwtFilter 를 SecurityConfig에 적용할때 사용할 JwtSecurityConfig 클래스를 생성합니다.\n\n```java\npublic class JwtSecurityConfig extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity> {\n\n    private TokenProvider tokenProvider;\n\n    public JwtSecurityConfig(TokenProvider tokenProvider) {\n        this.tokenProvider = tokenProvider;\n    }\n\n    @Override\n    public void configure(HttpSecurity http) {\n        JwtFilter customFilter = new JwtFilter(tokenProvider);\n        http.addFilterBefore(customFilter, UsernamePasswordAuthenticationFilter.class);\n    }\n}\n```\n\nSecurityConfigurerAdapter를 상속받고 TokenProvider를 주입받아서 configure 메소드를 Override 하여 JwtFilter를 통해 Security 로직에 필터를 등록합니다.\n\n## JwtAuthenticationEntryPoint 클래스\n\n유효한 자격증명을 제공하지 않고 접근하려 할때 401 Unauthorized 에러를 리턴할 JwtAuthenticationEntryPoint 클래스를 생성합니다.\n\n```java\n@Component\npublic class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {\n\n    @Override\n    public void commence(HttpServletRequest request,\n                         HttpServletResponse response,\n                         AuthenticationException authException) throws IOException {\n        // 유효한 자격증명을 제공하지 않고 접근하려 할때 401\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n    }\n}\n```\n\nAuthneticaionEntryPoint 를 구현하고, commence 메소드를 Override 합니다\n\n이 클래스는 유효하지 않는 자격증명은 401 에러를 전송하는 클래스입니다.\n\n## JwtAccessDeniedHandler 클래스\n\n필요한 권한이 존재하지 않는 경우에 403 Forbidden 에러를 리턴하기 위해 JwtAccessDeniedHandler 클래스를 생성합니다.\n\n```java\n@Component\npublic class JwtAccessDeniedHandler implements AccessDeniedHandler {\n\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException {\n        //필요한 권한이 없이 접근하려 할때 403\n        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n    }\n}\n```\n\nAccessDeniedHandler를 구현하하고, handle 메소드를 Override합니다.\n\n필요한 권한이 없이 접근할때 403 에러를 리턴합니다.\n\n# 3. Security 설정 추가\n\n## SecurityConfig 에 추가\n\n이제 만들었던 5개의 클래스를 SecurityConfig 에 적용하겠습니다.\n\n```java\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    private final TokenProvider tokenProvider;\n    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;\n    private final JwtAccessDeniedHandler jwtAccessDeniedHandler;\n\n    public SecurityConfig(\n            TokenProvider tokenProvider,\n            JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint,\n            JwtAccessDeniedHandler jwtAccessDeniedHandler\n    ) {\n        this.tokenProvider = tokenProvider;\n        this.jwtAuthenticationEntryPoint = jwtAuthenticationEntryPoint;\n        this.jwtAccessDeniedHandler = jwtAccessDeniedHandler;\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    @Override\n    public void configure(WebSecurity web) {\n        web.ignoring()\n                .antMatchers(\n                        \"/h2-console/**\"\n                        ,\"/favicon.ico\"\n                );\n    }\n\n    @Override\n    protected void configure(HttpSecurity httpSecurity) throws Exception {\n        httpSecurity\n                // token을 사용하는 방식이기 때문에 csrf를 disable합니다.\n                .csrf().disable()\n\n                .exceptionHandling()\n                .authenticationEntryPoint(jwtAuthenticationEntryPoint)\n                .accessDeniedHandler(jwtAccessDeniedHandler)\n\n                // enable h2-console\n                .and()\n                .headers()\n                .frameOptions()\n                .sameOrigin()\n\n                // 세션을 사용하지 않기 때문에 STATELESS로 설정\n                .and()\n                .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n\n                .and()\n                .authorizeRequests()\n                .antMatchers(\"/api/hello\").permitAll()\n                .antMatchers(\"/api/authenticate\").permitAll()\n                .antMatchers(\"/api/signup\").permitAll()\n\n                .anyRequest().authenticated()\n\n                .and()\n                .apply(new JwtSecurityConfig(tokenProvider));\n    }\n}\n```\n\n- `@EnableGlobalMethodSecurity` : @PreAuthorize 어노테이션을 메소드 단위로 추가한다\n\nSecurityConfig는 TokenProvider, JwtAuthenticaionEntryPoint, JwtAccessDeniedHandler 를 주입받습니다. \n\npasswordEncoder로 BCryptPasswordEncoder를 사용합니다.\n\nconfigure 메소드에서 많은 부분이 추가됬는데(HttpSecurity 매개인자) \n\n일단 토큰을 사용하기 때문에 csrf 는 disable 합니다 Exception을 핸들링할때 우리가 작성한 클래스를 추가합니다.\n\n그리고 h2-console 을 위한 설정들을 추가해줬고, 우리는 세션을 사용하지 않기 때문에 세션 설정을 STATELESS로 설정합니다.\n\n로그인 API, 회원가입 API 는 토큰이 없는 상태에서 요청이 들어오기 때문에 모두 permitAll 설정을 해줬습니다.\n\n마지막으로 JwtFilter를 addFilterBefore로 등록했던 JwtSecurityConfig 클래스도 적용해줍니다.\n\n### 서버 실행\n\n서버를 최종적으로 실행하면 아무 오류없이 잘 실행되는 것을 볼수있습니다.\n\n```java\n2022-01-10 20:36:56.570  INFO 44384 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''\n2022-01-10 20:36:56.575  INFO 44384 --- [           main] c.e.jwttutorial.JwtTutorialApplication   : Started JwtTutorialApplication in 2.078 seconds (JVM running for 2.671)\n```\n\n이제 JWT 설정 추가, JWT 관련 코드 개발, Security 설정 추가하는 작업이 완료되었습니다.\n\n다음편에서는 DB와 연결하는 Repository를 만들고 로그인 API 를 구현하겠습니다.","excerpt":"1. JWT 설정추가 application.yml 파일을 열고, jwt 설정을 추가하겠습니다. header : JWT를 검증하는데 필요한 정보 secret : HS512 알고리즘을 사용할 것이기 때문에 512bit, 즉 64byte 이상의 secre…","fields":{"slug":"/springboot-jwt-tutorial3/"},"frontmatter":{"date":"Jan 12, 2022","title":"SpringBoot JWT 튜토리얼 - 3장 JWT코드, Security 설정 추가","tags":["SpringBoot","JWT","튜토리얼"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# 1. JWT (Json Web Token)란?\n\n---\n\n- JSON 객체를 사용해서 토큰 자체에 정보를 저장하는 Web Token\n- Header, Payload, Signature 3개 부분으로 구성됨.\n- 쿠키나 세션을 이용한 인증보다 안전하고 효율적임\n- 일반적으로는 `Authorization : <type> <credentials>` 형태로 Request Header 에 담겨져 오기 떄문에 Header 값을 확인해서 가져올 수 있음.\n\n## 1.1 장단점\n\n---\n\n- 장점\n    - 중앙 인증 서버, 저장소에 대한 의존성이 없어서 수평확장에 유리\n    - Base64 URL Safe Encoding 이라 URL, Cookie, Header 어떤 형태로 사용가능\n    - Stateless 한 서버 구현 가능\n    - 웹이 아닌 모바일에서도 사용 가능\n    - 인증 정보를 다른 곳에서도 사용 가능 (OAuth)\n- 단점\n    - Payload 의 정보가 많아지면 네트워크 사용량 증가\n    - 다른 사람이 토큰을 decode 하여 데이터 확인 가능\n    - 토큰을 탈취당한 경우 대처하기 어려움\n        - 기본적으로는 서버에서 관리하는게 아니다보니 탈취당한 경우 강제 로그아웃 처리가 불가능\n        - 토큰 유효시간이 만료되기 전까지는 탈취자는 자유롭게 인증 가능\n        - 그래서 유효시간을 짧게 가져가고 refresh Token 을 발급하는 방식으로 많이 사용\n\n## 1.2 Token 구성요소\n\n---\n\n- Header\n    - `alg` : Signature 를 해싱하기 위한 알고리즘 정보를 갖고 있음\n    - `typ` : 토큰의 타입을 나타내는데 없어도 됨(보통 JWT 를 사용)\n- Payload\n    - 서버와 클라이언트가 주고받는, 시스템에서 실제로 사용될 정보에 대한 내용을 담고 있음\n    - JWT가 [기본적으로 갖고 있는 키워드](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1)가 존재\n    - 원한다면 추가 가능\n        - `iss` : 토큰 발급자\n        - `sub` : 토큰 제목\n        - `aud` : 토큰 대상\n        - `exp` : 토큰의 만료시간\n        - `nbf` : Not Before\n        - `iat` : 토큰이 발급된 시간\n        - `jti` : JWT의 고유 식별자\n- Signature\n    - 서버에서 토큰이 유효한지 검증하기 위한 문자열\n    - Header + Payload + Secret Key 로 값을 생성하므로 데이터 변조 여부를 판단 가능\n    - Secret Key 는 노출되지 않도록 서버에서 관리 필요\n\n## 1.3 토큰 인증 타입\n\n---\n\n`Authorization: <type> <credentials>` 형태에서 `<type>` 부분에 들어값 값.\n\n엄격한 규칙이 있는건 아니고, 일반적으로 많이 사용되는 형태\n\n- Basic\n    - 사용자 아이디와 암호를 Base64로 인코딩한 값을 토큰으로 사용\n- Bearer\n    - JWT 또는 OAuth 에 대한 토큰을 사용\n- Digest\n    - 서버에서 난수 데이터 문자열을 클라이언트에 보냄\n    - 클라이언트는 사용자 정보와 nonce 를 포함하는 해시값을 사용하여 응답\n- HOBA\n    - 전자 서명 기반 인증\n- Mutual\n    - 암호를 이용한 클라이언트-서버 상호 인증\n- AWS4-HMAC-SHA256\n    - AWS 전자 서명 기반 인증\n\n# 2. Refresh Token\n\n---\n\n**JWT 역시 탈취되면 누구나 API 를 호출할 수 있다는 [단점이](https://www.notion.so/JWT-6b901ef070744b6bb65fff7f5343fd35) 존재.**\n\n세션은 탈취된 경우 세션 저장소에서 탈취된 세션 ID를 삭제하면되지만, JWT 는 서버에서 관리하지 않기 때문에 속수무책으로 당할 수 밖에 없음.\n\n그래서 탈취되어도 피해가 최소한 되도록 유효시간을 짧게 가져감.\n\n하지만 만료 시간을 30분으로 설정하면 일반 사용자는 30분마다 새로 로그인하여 토큰을 발급받아야 함.\n\n**사용자가 매번 로그인 하는 과정을 생략하기 위해 필요한게 Refresh Token.**\n\n### 발급 과정\n\n1. Refresh Token 은 로그인 토큰(Access Token) 보다 긴 유효 시간을 가지며, Access Token 이 만료된 사용자가 재발급을 원할 경우 Refresh Toekn을 함께 전달함.\n2. 서버는 Access Token 에 담긴 사용자의 정보를 확인하고 Refresh Token 이 아직 만료되지 않았다면, 새로운 토큰을 발급해줌\n\n위와 같이 하면 매번 로그인해야하는 번거로움 없이 로그인을 지속적으로 유지 할 수 있음.\n\n### 주의\n\nRefresh Token 은 사용자가 로그인할 때 같이 발급되며, 클라이언트가 안전한 곳에 보관하고 있어야 함.\n\nAccess Token과 달리 매 요청마다 주고 받지 않기 때문에 탈취 당할 위험이 적으며, 요청 주기가 길기 때문에 별도의 저장소에 보관함. (정책마다 다르게 사용)\n\n## 2.1 Refresh Token 저장소\n\n---\n\nRefresh Token 은 서버에서 별도의 저장소에 보관하는 것이 좋다.\n\n- Refresh Token 은 사용자 정보가 없기 때문에 저장소에 값이 있으면 검증 시 어떤 사용자의 토큰인지 판단하기 용이\n- 탈취당했을 때 저장소에서 Refresh Token 정보를 삭제하면 Access Token 만료 후에 재발급이 안되게 강제 로그아웃 처리 가능\n- 일반적으로 Redis 많이 사용\n\n## 2.2 Refresh Token 으로 Access Token 재발급 시나리오\n\n---\n\n1. 클라이언트는 `access token` 으로 API 요청하며 서비스 제공\n2. `access token` 이 만료되면 서버에서 `access token` 만료 응답을 내려줌\n3. 클라이언트는 access token 만료응답을 받고 재발급을 위해 `access token + refresh token` 을 함께 보냄\n4. 서버는 `refresh token` 의 만료 여부를 확인\n5. `acces token` 으로 유저 정보(username 또는 userid) 를 획득하고 저장소에 해당 유저 정보를 key 값으로 한 value 가 `refresh token` 과 일치하는지 확인\n6.  4 - 5 번의 검증이 끝나면 새로운 토큰 세트 (access + refresh ) 발급\n7. 서버는 `refresh token` 저장소의 value 업데이트\n\n## 참고\n\n- [JWT Token 확인 가능한 사이트](https://jwt.io)\n- [참고한 블로그](https://bcp0109.tistory.com/321)","excerpt":"1. JWT (Json Web Token)란? JSON 객체를 사용해서 토큰 자체에 정보를 저장하는 Web Token Header, Payload, Signature 3개 부분으로 구성됨. 쿠키나 세션을 이용한 인증보다 안전하고 효율적임 일반적으로는…","fields":{"slug":"/json-web-token/"},"frontmatter":{"date":"Jan 10, 2022","title":"Json Web Token(JWT) 란?","tags":["보안","Token"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"## 1. 401 Unauthorized 해결을 위한 Security 설정\n\n### SecurityConfig 생성\n\n![Untitled](2-1.png)\n\nconfig 패키지를 생성한뒤, SecurityConfig 클래스를 작성합니다.\n\n- SecurityConfigurer 설정을 위한 두가지 방법\n    1. `WebSecurityConfigurer` 를 `implements` 하기\n    2. `WebSecurityConfigurerAdapter` 를 `extends` 하기\n    \n    위 코드에서는 2번째 방법으로 어댑터 클래스를 상속받아서 구현한다.\n    \n- `configure(HttpSecurity http)` 메소드 오바라이딩\n    \n    상속받은 클래스 내부를 보면, configure 함수가 오버로딩되어있는데, 이 코드에서는 HTTPSecurity 를 매개변수로 가지는 함수를 오버라이딩하여 작성한다.\n    \n- `authorizeRequests()`\n    - HttpServletRequest 를 사용한 요청들에 대한 접근제한\n    - HttpServletRequest?\n        \n        JSP 기본 내장 객체 중 **request 객체는 JSP에서 가장 많이 사용되는 객체**입니다.\n        \n        웹브라우저 사용자인 클라이언트로부터 서버로 요청이 들어오면 서버에서는 **HttpServletRequest**  를 생성하며, 요청정보에 있는 패스로 매핑된 서블릿에게 전달합니다.\n        \n        이렇게 전달받은 내용들을 파라미터로 Get과 Post 형식으로 클라이언트에게 전달합니다.\n        \n- `antMatchers(path).permitAll()`\n    - 해당 path 는 인증없이(permitAll) 접근허용한다.\n- `anyRequest().authenticated()`\n    - 그외 나머지 요청들은 인증되어야한다.\n\n### Postman으로 테스트\n- GET - localhost:8080/api/hello\n\n![Untitled](2-2.png)\n\n위와 같이 문자열 “hello” 가 반환이 된것을 볼수있습니다.\n\n## 2. Datasource, JPA 설정\n\n### properties → yml 로 변경\n\n기본적으로 스프링부트는 key - value 형식을 사용하는 [application.properties](http://application.properties) 파일이 있습니다.\n\n키에 동일한 접두사를 사용하여, 계층적 데이터를 표현합니다.\n\n해당 파일의 각 라인은 단일 구성이고, 모든 키는 spring.datasource에 속합니다.\n\n```\nspring.datasource.url=jdbc:h2:dev\nspring.datasource.username=SA\nspring.datasource.password=password\n```\n\nYAML 형식은 계층적 구성 데이터를 지정하기 편리한 형식입니다.\n\n```yaml\nspring:\n    datasource:\n        password: password\n        url: jdbc:h2:dev\n        username: SA\n```\n\n따라서 위 두가지 차이를 보면, YAML 형식은 가독성이 좋고, 하나의 파일로, 프로필을 구분할 수 있는 장점이있다.\n\n보기 좋은 것을 선호하면 YAML 형식을 사용하거나, 이전 형식대로 사용해도 상관없습니다.\n\n인텔리제이의 Refactor를 이용해 application.properties 의 확장자를 yml로 변경합니다.\n\n![Untitled](2-3.png)\n\nH2 데이터베이스를 사용할 것 이고, 메모리에 데이터를 저장합니다.\n\n- h2.console.enabled\n    - h2 콘솔 페이지 활성화\n- jpa.hibernate.ddl-auto\n    - Hibernate 초기화 전략, create-drop 은 인-메모리 DB 기본 전략입니다.\n    - SessionFactory가 시작될 때, Drop, Create, Alter 종료될때 Drop\n- jpa.properties.hibernate\n    - 콘솔창에서 sql 문을 보기좋게 출력\n- logging.level\n    - log4j 의 로그레벨은 ALL < DEBUG < INFO < WARN < ERROR < FATAL < OFF 순으로 지정.\n\n## 3. Entity 생성\n\nentity 패키지를 생성하고, User, Authority 를 생성합니다.\n\n```java\n@Entity\n@Table(name = \"user\")\n@Getter\n@Setter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User {\n\n    @Id\n    @Column(name = \"user_id\")\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long userId;\n\n    @Column(name = \"username\", length = 50, unique = true)\n    private String username;\n\n    @Column(name = \"password\", length = 100)\n    private String password;\n\n    @Column(name = \"nickname\", length = 50)\n    private String nickname;\n\n    @Column(name = \"activated\")\n    private boolean activated;\n\n    @ManyToMany\n    @JoinTable(\n            name = \"user_authority\",\n            joinColumns = {@JoinColumn(name = \"user_id\", referencedColumnName = \"user_id\")},\n            inverseJoinColumns = {@JoinColumn(name = \"authority_name\", referencedColumnName = \"authority_name\")})\n    private Set<Authority> authorities;\n}\n```\n\n```java\npackage com.example.jwttutorial.entity;\n\nimport lombok.*;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Id;\nimport javax.persistence.Table;\n\n@Entity\n@Table(name = \"authority\")\n@Getter\n@Setter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Authority {\n\n    @Id\n    @Column(name = \"authority_name\", length = 50)\n    private String authorityName;\n}\n```\n\n![Untitled](2-4.png)\n\nUser 클래스를 보면 @ManyToMany, @JoinTable 은 유저와 권한 객체의 다대다 관계를 위 테이블 처럼 일대다, 다대일 관계의 조인 테이블로 정의했습니다. \n\n이 부분은 추후 강의자의 JPA 강의에서 자세히 설명합니다. \n\n### data.sql 생성\n\n편의를 위해, 서버를 시작할때마다 Data를 자동으로 DB에 넣어주는 기능을 활용하겠습니다.\n\n resource 폴더 밑에 data.sql 파일을 만들겠습니다.\n\n```sql\nINSERT INTO USER (USER_ID, USERNAME, PASSWORD, NICKNAME, ACTIVATED) VALUES (1, 'admin', '$2a$08$lDnHPz7eUkSi6ao14Twuau08mzhWrL4kyZGGU5xfiGALO/Vxd5DOi', 'admin', 1);\nINSERT INTO USER (USER_ID, USERNAME, PASSWORD, NICKNAME, ACTIVATED) VALUES (2, 'user', '$2a$08$UkVvwpULis18S19S5pZFn.YHPZt3oaqHZnDwqbCW9pft6uFtkXKDC', 'user', 1);\n\nINSERT INTO AUTHORITY (AUTHORITY_NAME) values ('ROLE_USER');\nINSERT INTO AUTHORITY (AUTHORITY_NAME) values ('ROLE_ADMIN');\n\nINSERT INTO USER_AUTHORITY (USER_ID, AUTHORITY_NAME) values (1, 'ROLE_USER');\nINSERT INTO USER_AUTHORITY (USER_ID, AUTHORITY_NAME) values (1, 'ROLE_ADMIN');\nINSERT INTO USER_AUTHORITY (USER_ID, AUTHORITY_NAME) values (2, 'ROLE_USER');  \n```\n\n## 4. H2 Console 결과 확인\n\n우리가 만들었던 엔티티들이 DB에 생성이 되는지 확인을 해봅니다. \n\n그 전에 Security 설정을 추가해줘야지 h2-console 접근을 원할하게 할 수 있습니다.\n\n![Untitled](2-5.png)\n\nh2-console 하위 모든 요청들과 파비콘 관련 요청은 Spring Security 로직을 수행하지 않고 접근할 수 있도록 \n\nconfigure(WebSecurity) 메소드를 오버라이딩 합니다.\n\n그 후 서버를 시작합니다.\n\n- DB 초기화 중 에러 발생\n    \n    ```java\n    2022-01-07 16:36:18.468  WARN 2873 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSourceScriptDatabaseInitializer' defined in class path resource [org/springframework/boot/autoconfigure/sql/init/DataSourceInitializationConfiguration.class]: Invocation of init method failed; nested exception is org.springframework.jdbc.datasource.init.ScriptStatementFailedException: Failed to execute SQL script statement #1 of URL [file:/Users/seonghun/Desktop/dev/projects/jwt-tutorial/build/resources/main/data.sql]: INSERT INTO USER (USER_ID, USERNAME, PASSWORD, NICKNAME, ACTIVATED) VALUES (1, 'admin', '$2a$08$lDnHPz7eUkSi6ao14Twuau08mzhWrL4kyZGGU5xfiGALO/Vxd5DOi', 'admin', 1); \n    nested exception is org.h2.jdbc.JdbcSQLSyntaxErrorException: Table \"USER\" not found; SQL statement:\n    \n    INSERT INTO USER (USER_ID, USERNAME, PASSWORD, NICKNAME, ACTIVATED) VALUES (1, 'admin', '$2a$08$lDnHPz7eUkSi6ao14Twuau08mzhWrL4kyZGGU5xfiGALO/Vxd5DOi', 'admin', 1) [42102-200]\n    ```\n    <br/>\n    hibernate 초기화 과정에 에러가 발생했습니다.\n    \n    Spring Boot Application 구동하는 과정 중에 `data.sql`을 실행하는 도중, User 테이블을 찾을 수 없어 Insert 구문에서 오류가 발생하는 것인데. \n    \n    강의에서 스프링부트의 버전은 2.4이고 현재 2.6 인데 버전이 업데이트 되면서 이러한 오류가 발생하는 듯 합니다.(대부분의 오류는 버전업데이트 관련을 많이겪음)\n    <br/>\n    - Hibernate and data.sql 공식 노트 내용 ([릴리즈 노트 링크)](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.5-Release-Notes)\n    \n    > By default, data.sql scripts are now run before Hibernate is initialized. This aligns the behavior of basic script-based initialization with that of Flyway and Liquibase. If you want to use data.sql to populate a schema created by Hibernate, set spring.jpa.defer-datasource-initialization to true. While mixing database initialization technologies is not recommended, this will also allow you to use a schema.sql script to build upon a Hibernate-created schema before it’s populated via data.sql.\n    > \n    \n    Spring Boot 2.5버전 부터 스크립트 기반 초기화의 동작과정을 Flyway, Liquibase와 일치시키기 위해서 `data.sql` 은 Hibernate 초기화되기 전에 실행된다는 내용인것 같습니다.\n    \n    따라서 Hibernate 초기화를 통해 생성된 스키마에다가 데이터를 채우기를 위해서 `data.sql`가 실행되기를 원한다면 **application.yml**(또는 properties)에 **`spring.jpa.defer-datasource-initialization`** 옵션 값을 **true**로 추가해주어야 합니다. \n    \n    또는 `schema.sql`을 추가해서 hibernate 가 스키마를 생성하는 과정보다 먼저 실행되도록하여 해당 스키마에 data.sql을 채우도록하는 방법도 있다고 합니다. 그러나 DB 초기화 기술을 혼합하여 사용하는 것은 권장하지 않는 방법이라고 합니다.\n    \n    따라서 application.yml 에 `defer-datasource-initialization: true` 옵션을 권장하지 않지만 추가합니다.\n    \n\n```sql\n2022-01-07 16:43:40.706  INFO 2951 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect\nHibernate: \n    \n    drop table if exists authority CASCADE \nHibernate: \n    \n    drop table if exists user CASCADE \nHibernate: \n    \n    drop table if exists user_authority CASCADE \nHibernate: \n    \n    create table authority (\n       authority_name varchar(50) not null,\n        primary key (authority_name)\n    )\nHibernate: \n    \n    create table user (\n       user_id bigint generated by default as identity,\n        activated boolean,\n        nickname varchar(50),\n        password varchar(100),\n        username varchar(50),\n        primary key (user_id)\n    )\nHibernate: \n    \n    create table user_authority (\n       user_id bigint not null,\n        authority_name varchar(50) not null,\n        primary key (user_id, authority_name)\n    )\nHibernate: \n    \n    alter table user \n       add constraint UK_sb8bbouer5wak8vyiiy4pf2bx unique (username)\nHibernate: \n    \n    alter table user_authority \n       add constraint FK6ktglpl5mjosa283rvken2py5 \n       foreign key (authority_name) \n       references authority\nHibernate: \n    \n    alter table user_authority \n       add constraint FKpqlsjpkybgos9w2svcri7j8xy \n       foreign key (user_id) \n       references user\n```\n\nHibernate DB 초기화 오류를 해결하고 실행을 하니, 로그에 SQL 문을 볼수있습니다. \n\n이 로그들을 보면, 우리가 만들어둔 Entity 내용들을 기반으로 DB 관련 정보들을 생성하는 쿼리들이 잘 수행 된것을 볼수있습니다.\n\n### 실제 DB 반영 확인\n\n[localhost:8080/h2-console](http://localhost:8080/h2-console) 에 접속합니다. (인증을 무시하도록 설정했으므로,접속이 잘 되야합니다)\n\n![Untitled](2-6.png)\n\n우리가 만들었던 Entity 정보들과 data.sql 파일의 쿼리내용들이 잘 들어와있는것을 볼수있습니다.\n\n다음 강의에는 JWT 관련 코드들을 작성하겠습니다.\n\n### Reference\n\n[HttpServletRequest 개념](https://chobopark.tistory.com/43)\n\n[properties → YAML](https://devgoat.tistory.com/15)\n\n[log4j loggin level](https://myblog.opendocs.co.kr/archives/950)\n\n[hibernate ddl-auto 초기화전략](https://pravusid.kr/java/2018/10/10/spring-database-initialization.html)\n\n[스프링부트 2.5 hibernate data.sql](https://velog.io/@khsb2012/스프링-부트-2.5-업데이트-hibernate-data.sql-관련-변동사항)","excerpt":"1. 401 Unauthorized 해결을 위한 Security 설정 SecurityConfig 생성  config 패키지를 생성한뒤, SecurityConfig 클래스를 작성합니다. SecurityConfigurer 설정을 위한 두가지 방법  를 …","fields":{"slug":"/springboot-jwt-tutorial2/"},"frontmatter":{"date":"Jan 08, 2022","title":"SpringBoot JWT 튜토리얼 - 2장 Security 설정, Data 설정","tags":["SpringBoot","JWT","튜토리얼"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n인프런 강의(Spring Boot JWT Tutorial)를 수강하며, 내용들을 기록한 페이지입니다.\n\n- 배우는 것\n    - Spring Boot를 이용한 JWT 인증, 인가 구현\n    - Spring Security 기초\n    - 회원가입, 로그인, 권한로직\n\n# JWT 소개 ([JWT.io](http://JWT.io) [홈페이지](https://jwt.io))\n\n---\n\n![Untitled](1-1.png)\n\nJWT 는 Json 객체를 사용하여 토큰 자체에 정보들을 저장하고 있는 Web Token 이라 할 수 있다.\n\n특히, JWT를 이용하는 방식은 헤비하지 않고 아주 간편하고 쉽게 적응할 수 있다.\n\n- JWT 는 Header, Payload, Signature  3개의 부분으로 구성되어 있다.\n    - Header : Signature 를 해싱하기 위한 알고리즘 정보들이 담김\n    - Payload :  서버와 클라이언트가 주고받는, 시스템에서 실제로 사용될 정보에 대한 내용들을 담고있다.\n    - Signature : 토큰의 유효성 검증을 위한 문자열\n- 장점\n    - 중앙의 인증서버, 데이터 스토어에 대한 의존성 없음, 수평확장에 유리\n    - Base64 URL Safe Encoding  > URL, Cookie, Header 모두 사용 가능\n- 단점\n    - Payload 의 정보가 많아지면 네트워크 사용량 증가, 데이터 설계 고려 필요\n    - 토큰이 클라이언트에 저장, 서버에서 클라이언트의 토큰을 조작할 수 없음\n\n## 프로젝트 생성\n\n---\n\n### 1. 스프링 이니셜라이저를 통한 프로젝트 생성\n\n![Untitled](1-2.png)\n\n- 프로젝트 메타데이터를 입력한다\n- 자바 버전은 8\n- 빌드 도구는 Gradle\n\n![Untitled](1-3.png)\n\n- 스프링 부트 버전은 2.6.2 (강좌는 2.4.1임)\n- 추가한 의존성\n    - Lombok (편의성)\n    - Spring Web\n    - Spring Security\n    - h2 Database\n    - Spring Data JPA\n    - Validation\n    \n\n![Untitled](1-5.png)\n\n- 프로젝트가 생성된 모습\n\n![Untitled](1-4.png)\n\n- Lombok을 사용하므로 Enable annotaion processing 을 체크하자.\n\n### 2. 간단한 Rest API 테스트\n\n![Untitled](1-6.png)\n\n간단한 문자열(hello)을 리턴해주는 api를 만들고 테스트해보겠습니다.\n\n- `RestController` : 컨트롤러를 JSON을 반환하는 컨트롤러로 만들어 줍니다.\n- `RequestMapping` : 요청에 대해 어떤 Controller가 처리할지를 맵핑하기 위한 어노테이션.\n- `GetMapping` : HTTP Method인 Get인 요청을 받을 수 있는 API를 만들어 준다.\n- `ResponseEntity<>` : 사용자의 HttpRequest에 대한 응답 데이터를 포함하는 클래스.\n- `ResponseEntity.ok()`: 정상적인 요청이면 메소드의 파라미터 내용을 반환한다.\n\n위 코드를 작성하고 애플리케이션을 실행하고 Postman을 통해서 해당 url로 요청을 보내겠습니다.\n\n![Untitled](1-7.png)\n\n요청을 보내면 401 HTTP 상태 코드가 반환된 것을 볼 수 있습니다.\n\n이를 해결하기 위한 Security 설정과, 기본적인 Data 설정을 하겠습니다.\n\n### Reference\n\n- [ResponseEntity 스프링 공식 문서](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html)","excerpt":"인프런 강의(Spring Boot JWT Tutorial)를 수강하며, 내용들을 기록한 페이지입니다. 배우는 것 Spring Boot를 이용한 JWT 인증, 인가 구현 Spring Security 기초 회원가입, 로그인, 권한로직 JWT 소개 (JW…","fields":{"slug":"/springboot-jwt-tutorial1/"},"frontmatter":{"date":"Jan 07, 2022","title":"SpringBoot JWT 튜토리얼 - 1장 JWT소개,프로젝트생성","tags":["SpringBoot","JWT","튜토리얼"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"# asdf란? ([asdf 설치 하기](https://subicura.com/mac/dev/terminal-apps.html#asdf))\n\nasdf-vm은 mac OS의 각종 프로그램의 버전을 손쉽게 관리해주는 **성의 없어 보이는 이름**의 도구입니다.<br/>\n기존에 nvm, rbenv등 언어, 프로그램별로 달랐던 관리 도구를 하나로 통합해서 사용할 수 있습니다. <br/>\nhomebrew도 일부 버전 관리 기능을 제공하지만 asdf만큼 강력하지 않습니다.<br/>\nasdf를 이용하면 버전 별로 설치할 수 있는 장점이 있습니다.<br/>\n그래서 이번에는 Java 8 JDK와, Java 11 JDK 를 둘다 설치하는 것을 해보겠습니다.<br/>\n\n\n## 시작\n\n```json\n❯ java --version\nopenjdk 11.0.13 2021-10-19 LTS\nOpenJDK Runtime Environment Zulu11.52+13-CA (build 11.0.13+8-LTS)\nOpenJDK 64-Bit Server VM Zulu11.52+13-CA (build 11.0.13+8-LTS, mixed mode)\n```\n\n현재 저의 자바 jdk 버전은 11입니다. 저는 jdk 8 버전의 자바 환경도 만들고 싶습니다. \n<br/>그럴려면 환경변수도 매번 지정해줘야하는 번거로움이 있습니다. \n<br/>asdf 를 이용해서 8버전과 11버전을 유연하게 돌아가며 사용할 수 있는 환경을 만들어 보겠습니다.\n\n### 이전에 이미 설치한 JAVA JDK 는 어떡합니까?\n\n만약 brew를 통해서 java를 설치하신 분이라면 brew uninstall 을 통해 jdk를 삭제하면 되고.\n\n아니면 아래 명령어를 통해 삭제하시면 됩니다.\n\n```json\n❯ sudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin\n❯ sudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefPane\n❯ sudo rm -fr ~/Library/Application\\ Support/Java\n\n❯ cd /Library/Java/JavaVirtualMachines/ \n❯ ls \n❯ sudo -rm -rf jdk-x.x.x.jdk\n```\n\n### JAVA Plugin 추가\n\n[asdf-java plugin 깃허브 링크](https://github.com/halcyon/asdf-java#java_home)\n\n- 먼저 자바 플러그인을 추가합니다\n\n```json\n❯ asdf plugin-add java https://github.com/halcyon/asdf-java.git\n```\n\n### 자바 플러그인 업데이트\n\n플러그인 목록을 최신화합니다.\n\n```json\n❯ asdf plugin update java\n```\n\n### 자바 버전 별 플러그인 보기\n\n아래 명령어를 이용하면 설치할 수 있는 자바의 버전들이 나타납니다.\n\n```json\n❯ asdf list-all java\n...\nsapmachine-jre-18-internal.0\ntemurin-17.0.0+35\ntemurin-17.0.1+12\ntemurin-jre-17.0.1+12\nzulu-8.52.0.23\nzulu-8.54.0.21\nzulu-8.56.0.23\nzulu-8.58.0.13\nzulu-11.43.1017\nzulu-11.43.1021\nzulu-11.45.27\nzulu-11.48.21\nzulu-11.50.19\nzulu-11.52.13\nzulu-13.35.1019\nzulu-13.35.1025\nzulu-13.37.21\nzulu-13.40.15\nzulu-13.42.17\nzulu-13.44.13\nzulu-15.28.1013\nzulu-15.29.15\nzulu-15.32.15\nzulu-15.34.17\nzulu-15.36.13\nzulu-16.28.11\nzulu-16.30.15\nzulu-16.30.19\nzulu-16.32.15\nzulu-17.28.13\nzulu-17.30.15\n...\n```\n\n(라이선스 문제없는 jdk를 설치하시면 됩니다). [[JDK 라이선스 유료화]](https://zdnet.co.kr/view/?no=20181102140004)\n\n### JAVA 8, 11 버전 설치\n\n자바 8버전과 11버전의 openjdk를 설치하겠습니다.\n\n```json\n❯ asdf install java zulu-8.58.0.13\n❯ asdf install java zulu-11.52.13\n```\n\n### asdf 설치한 자바 버전 확인하기\n\n아래 명령어를 통해, 설치된 자바 버전들을 볼수있습니다.\n\n```json\n❯ asdf list java\n  zulu-11.52.13\n  zulu-8.58.0.13\n```\n\n### Global 버전으로 지정하기\n\n설치한 버전을 전역 버전으로 지정합니다. 즉 내 컴퓨터의 자바 버전을 지정한 버전으로 설정합니다.\n\n저는 8버전을 지정했습니다.\n\n```json\n❯ asdf global java zulu-8.58.0.13\n```\n\n### JAVA_HOME 설정하기\n\n[sadf java-plugin JAVA_HOME 설정](https://github.com/halcyon/asdf-java#java_home)\n\n아래 명령어를 실행하면, 자바 위치를 지정합니다. (처음 한번만 실행하면 됩니다)\n\n```json\n. ~/.asdf/plugins/java/set-java-home.zsh\n```\n\n### 자바 버전 확인하기\n\n아래 명령어를 통해 정상적으로 설치되었는지 확인합니다.\n\n```json\n❯ java -version\nopenjdk version \"1.8.0_312\"\nOpenJDK Runtime Environment (Zulu 8.58.0.13-CA-macos-aarch64) (build 1.8.0_312-b07)\nOpenJDK 64-Bit Server VM (Zulu 8.58.0.13-CA-macos-aarch64) (build 25.312-b07, mixed mode)\n```\n\n정상적으로 8버전의 jdk가 나오는 것을 볼 수 있습니다.\n\n또한 자바 환경 변수 위치까지 jdk 8로 변경된 것 을 볼 수 있습니다.\n\n```json\n❯ echo $JAVA_HOME\n/Users/seonghun/.asdf/installs/java/zulu-8.58.0.13/zulu-8.jdk/Contents/Home\n```\n\n### 현재 전역으로 설정된 버전들 보기\n\n자바 뿐만 아니라 다른 프로그램들의 버전 현황을 볼 수 있습니다. (global version)\n\n```json\n❯ asdf current\njava            zulu-8.58.0.13  /Users/seonghun/.tool-versions\nnodejs          lts-fermium     Not installed. Run \"asdf install nodejs lts-fermium\"\nyarn            1.22.17         /Users/seonghun/.tool-versions\n```\n\n### 자바 버전 변경하기\n\n아래 명령어를 통해 11버전의 자바 jdk 로 변경하겠습니다.\n\n```json\n❯ asdf global java zulu-11.52.13\n```\n\n그 후 정상적으로 버전이 변경됬는지 확인하겠습니다.\n\n```json\n❯ java --version\nopenjdk 11.0.13 2021-10-19 LTS\nOpenJDK Runtime Environment Zulu11.52+13-CA (build 11.0.13+8-LTS)\nOpenJDK 64-Bit Server VM Zulu11.52+13-CA (build 11.0.13+8-LTS, mixed mode)\n```\n\n8버전에서 11버전으로 변경된 것 을 확인할 수 있습니다.\n\n아래 명령어로 자바 환경변수 경로까지 자동으로 변경된 것 을 볼수있습니다.\n\n```json\n❯ echo $JAVA_HOME\n/Users/seonghun/.asdf/installs/java/zulu-11.52.13/zulu-11.jdk/Contents/Home\n```\n\n### 결론\n\n`asdf globale java <version>` 명령어 한 줄 만으로 자바 버전을 쉽게 변경할 수 있었습니다.\n\n(원래라면 자바 버전을 버전마다 변수로 추가해줘야함)\n\n자바 뿐만 아니라 npm, yarn 같은 패키지 매니저 또한 지원하니 검색해서 유용하게 쓰시면 되겠습니다.\n\n---\n\n[참고](https://www.wiserfirst.com/blog/install-java-with-asdf/)\n\n[subicura 님 mac asdf 설치](https://subicura.com/mac/dev/terminal-apps.html#asdf/)\n\n[맥에서 Brew로 자바 설치하기(자바 버전 바꾸기)](https://llighter.github.io/install-java-on-mac/)","excerpt":"asdf란? (asdf 설치 하기) asdf-vm은 mac OS의 각종 프로그램의 버전을 손쉽게 관리해주는 성의 없어 보이는 이름의 도구입니다.\n기존에 nvm, rbenv등 언어, 프로그램별로 달랐던 관리 도구를 하나로 통합해서 사용할 수 있습니다.…","fields":{"slug":"/asdf-java/"},"frontmatter":{"date":"Jan 05, 2022","title":"asdf 를 이용한 JAVA 버전 별 설치","tags":["JAVA","자바","asdf"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"## Spring Security란?\n\n- Spring 기반의 애플리케이션의 보안(인증과 권한, 인가 등)을 담당하는 스프링 하위 프레임워크\n- **인증**과 **권한**에 대한 부분을 **Filter** 흐름에 따라 처리\n    - Filter는 Dispatcher Servlet 으로 가기전에 적용\n    - 따라서 가장 먼저 URL 요청을 받는다.\n    - 하지만, Interceptor는 Dispatcher와 Contoller 사이에 위치한다는 점에서 적용 시기의 차이가 있다.\n\n### 인증(Authentication)과 인가(Authorization)\n\n- 인증(Authentiacation) : 해당 사용자가 본인이 맞는지를 **확인**하는 절차\n- 인가(Authorization) : 인증된 사용자가 요청한 자원에 접근 가능한지를 결정하는 절차\n\n> Authentiacation → (인증 성공 후) → Authorization\n> \n\n- Spring Security는 기본적으로 인증 절차를 거친 후, 인가 절차를 진행\n- 인가 과정에서 해당 리소스에 대한 접근 권한이 있는지를 확인하게 된다.\n- Spring Security에서는 이러한 인증과 인가를 위해 Principal을 아이디로, Credential을 비밀번호로 사용하는 **Credential 기반의 인증 방식을** 사용한다.\n    - Principal(접근 주체) : 보호받는 리소스에 접근하는 대상\n    - Credential(비밀전호) : 리소스에 접근하는 대상의 비밀번호","excerpt":"Spring Security란? Spring 기반의 애플리케이션의 보안(인증과 권한, 인가 등)을 담당하는 스프링 하위 프레임워크 인증과 권한에 대한 부분을 Filter 흐름에 따라 처리 Filter는 Dispatcher Servlet 으로 가기전에…","fields":{"slug":"/spring-security-1/"},"frontmatter":{"date":"Jan 04, 2022","title":"SpringSecurity 란?","tags":["Spring Security"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n개인적으로 참고할려고 기록하는 글입니다.\n\n## MSA 구성요소 및 패턴의 유형\n\n- 인프라 구성요소 : 마이크로서비스를 지탱하는 하부구조 인프라를 구축하는데 필요한 구성요소\n- 플랫폼 패턴 : 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패턴\n- 애플리케이션 패턴 : 마이크로서비스 애플리케이션을 구성하는데 필요한 패턴\n\n## 서비스 유형별 대표적인 클라우드 서비스\n\n- `Iaas(Infrastructure as a Service)` :\n  가상 머신, 스토리지, 네트워크 같은 인프라를 필요한 만큼 적시에 제공하는 서비스\n  (예시 : AWS EC2, GCP Compute Engine, Azure VM)\n\n- `CaaS(Container as a Service)` :\n  컨테이너 기반 가상화를 사용해 컨테이너를 업로드, 구성, 실행, 확장, 중지할 수 있는 서비스\n  (예시 : Google Kubernetes Engine, AWS ECS)\n\n- `Paas(Platform as a Service)` : 애플리케이션을 즉시 개발, 실행, 관리할 수 있는 플랫폼 환경 서비스\n  (예시 : Azure Web App, Google App Engine, Heroku, AWS Elastic Beanstalk)\n\n## 개발 지원 환경 DevOps\n\n- `DevOps` : 마이크로서비스를 빌드하고 테스트한 뒤 배포할 수 있게 도와주는 개발 지원 환경\n\n- `CI/CD` - 자동화된 빌드나 배포작업,\n\n  - `CI`는 `지속적 통합(Continuous Integration)` 자동으로 통합 및 테스트하고 그 결과를 기록하는 활동\n  - `CD`는 `지속적 제공(Continuous Delivery)` 및 `지속적 배포(Continouss Deployment)` 실행환경에 내보내는 활동\n  - `지속적 제공`은 빌드된 소스코드의 실행 파일을 실행환경에 반영하기 위해 승인 및 배포 담당자의 허가를 받아야하고\n    배포도 수동으로 처리한다.\n  - `지속적 배포`은 소스코드 저장소(Github)에서 빌드한 소스코드의 실행 파일을 실행 환경 까지 자동으로 배포하는 방식\n    모든 영역을 자동화하는 것에 해당함.\n\n- `Infrastructure as a Code` - 인프라 구성을 마치 프로그래밍하는 것 처럼 처리하고 소수의 인원으로 컨테이너 배포 처리하는 과정\n  (배포 파이프라인 절차를 코드로 완벽히 자동화)\n\n## MSA 주요 아키텍처 패턴\n\n- Spring Cloud + DevOps\n  - Spring Cloud : Spring Boot + Netflix OSS\n\n## 참고한 자료\n\n- [도메인 주도 설계로 시작하는 마이크로서비스 개발](http://www.yes24.com/Product/Goods/98880996)","excerpt":"개인적으로 참고할려고 기록하는 글입니다. MSA 구성요소 및 패턴의 유형 인프라 구성요소 : 마이크로서비스를 지탱하는 하부구조 인프라를 구축하는데 필요한 구성요소 플랫폼 패턴 : 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패…","fields":{"slug":"/msa-related-term/"},"frontmatter":{"date":"Sep 28, 2021","title":"마이크로서비스 아키텍처(MSA) 관련 용어 정리","tags":["MSA","마이크로서비스 아키텍쳐","정리"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n처음에는 Jekyll로 블로그를 만들었는데 생각보다 마음에 안들어서, 검색하다보니 Gatsby를 발견했다.\nGatsby는 `React` 프레임워크를 기반으로 만들었는데 React를 전에 한번 입문해봐서 이걸로 선택했다.\n<br>\n<br>\n처음에는 `npm`으로 node module를 설치해서 환경을 구성했는데. 후반에 가니깐 한번 꼬이니깐 계속 꼬여서\nnpm을 재설치하고 시간을 많이 잡아 먹었다. 그래서 `yarn`으로 다시 패키지 설치하고 하니 잘되더라.\n<br>\n<br>\n# 1. Gatsby 설치\n\n## Gatsby-cli 설치\n패키지 매니저를 통해서 `gatsby-cli`를 설치한다.\n``` sh\n# npm\nnpm install -g gatsby-cli\n```\n```sh\n# yarn\nyarn add gatsby-cli\n```\n\n## 테마 설치\n```sh\ngatsby new [디렉터리 이름] [테마 깃허브 주소]\n```\n디렉터리에 다운받은 테마가 위치된다.\n```sh\ncd [디렉터리 이름]\nyarn start\n```\n\n그후 [localhost:8000](localhost:8000) 를 접속해서 설치한 테마를 맛본다.\n\n# 2. 나만의 블로그로 꾸미기\n## 포스트 위치\n다음 위치에서 블로그 포스팅을 추가할 수 있다.\n\n- `content/blog` : 포스트 파일 위치\n- `content/__about` : 프로필 파일 위치\n\n<br>\n\n포스트 파일은 `.markdown` 또는 `.md`을 사용한다.\n<br>\n\n## 메타데이터\n`gatsby-config.js` 파일이나 `gatsby-meta-config.js`파일에서 \n<br>\n블로그를 설정하는\n여러 요소를 수정할 수 있다.\n원하는 설정으로 수정하면된다.\n\n그 외의 설정은 \n`gatsby-browser.js`, `gatsby-node.js`을 참고\n\n## CSS 파일\n`src/styles` 위치에서 CSS 속성들을 수정할 수 있다.\n\n<br>\n직접 설정을 다하면 글을 한번 작성해봐서 깃허브 저장소나 자신만의 서버에서 배포하면된다.\n\n# 3. SEO 적용\nSEO는 `search engine optimization`로 검색 엔진 최적화, 구글이나 네이버에서 우리 블로그를 찾기 쉽도록 사이트를 개선하는 프로세스이다.\n\n## sitemap.xml 생성\n검색엔진에 검색이 잘 되게 할려면 웹 크롤러가 우리 사이트를 찾아와 크롤링을 하는데, 우리는 이정표를 만들어줘야한다.\n`sitemap.xml`이 이정표 역활을 한다.\n<br>\ngatsby는 `sitemap.xml`을 자동 생성해주는 플러그인이 있다. 추가하자\n<br>\n<br>\n`gastby-config.js`\n```js\n    plugins: [\n        ...\n        'gatsby-plugin-sitemap',\n    ]\n```\nplugins에 추가하면 build 될 때 마다 파일을 생성해준다.\n\n<br>\n그 후 플러그인을 설치하고, gatsby를 실행 한다.\n\n```sh\nyarn add gatsby-plugin-sitemap\ngatsby develop\n```\n\n[http://localhost:8000/sitemap.xml](http://localhost:8000/sitemap.xml)에 접속\n\n```xml\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\" xmlns:mobile=\"http://www.google.com/schemas/sitemap-mobile/1.0\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\">\n    <url>\n    ...\n    </url>\n</urlset>\n```\n위와 같은 xml 형식의 문서가 나오면 성공.\n\n## rss.xml 생성\nrss는 사이트를 방문하지 않아도 그 사이트의 새로운 글이 올라오면 알람을 준다고 생각하면된다.\n그리고 rss를 등록하는것도 검색엔진최적화 작업에 해당된다.\n\n```sh\nyarn add gatsby-plugin-feed\n```\n`sitemap`과 마찬가지로 build 할때마다 새로운 파일을 생성해야 하니 plugins에 추가하자.\n\n`gastby-config.js`\n```js\n    plugins: [\n        ...\n        'gatsby-plugin-feed',\n    ]\n```\n`rss.xml` 이 제대로 생성됬는지 확인하자\n```sh\ngatsby develop\n```\n그 후 [http://localhost:8000/rss.xml](http://localhost:8000/rss.xml)에 접속\n<br>\n`rss.xml` 페이지가 제대로 나온다면 성공.\n\n## robots.txt 생성\n`robots.txt`도 웹 크롤러가 사이트에 접속하면 찾는 파일이므로 만들어준다.\n\n```sh\nyarn add gatsby-plugin-robots-txt\n```\n`gastby-config.js`\n\n```js\nplugins: [\n\t...\n\t{\n      resolve: 'gatsby-plugin-robots-txt',\n      options: {\n        host: 웹사이트경로,\n        sitemap: 웹사이트경로/sitemap.xml',\n        policy: [{\n          userAgent: '*',\n          allow: '/'\n        }]\n      }\n    },\n\t...\n]\n```\n그리고 빌드해서 확인.\n\n```sh\ngatsby develop\n```\n그 후 [http://localhost:8000/robots.txt](http://localhost:8000/robots.txt)에 접속해\n`robots.txt`가 생성됬는지 확인한다.\n\n## 구글 서치 콘솔(GSC) 등록\n[구글등록](https://search.google.com/search-console/about)에서 시작하기를 통해 등록한다.\n우측에 URL 접두어를 선택하고 인증용 html 파일을 다운로드한다.\n다운받은 html 파일은 프로젝트 경로에 복사하고 `package.json`에서 build 스크립트를 작성한다.\n<br>\n`package.json`\n\n```json\n  \"scripts\": {\n        ...\n        \"copy\" : \"cp content/google인증용파일.html public/\",\n        \"build\": \"gatsby build && npm run copy\",\n        ...\n  }\n```\n빌드시 `npm run copy`를 통해 인증 html 파일을 public 경로로 복사해 줄 것이다.\n\n```\nyarn build\ngatsby serve\n```\n를 통해 \"http://localhost:9000/google인증파일.html\" 접속해서 잘 뜨는지 확인한다.\n그리고 sitemaps 메뉴내에 빈칸에 `sitemap.xml` 입력하고 제출한다.\n\n그러면 구글검색엔진에 등록되기까진 몇시간정도 걸리므로 기다리고 검색창에 `site: 블로그주소` 를 입력해서 확인하자.\n\n\n## 네이버 검색 노출\n\n네이버 검색도 구글에 하던것처럼 하면된다.\nhttps://searchadvisor.naver.com/console/board 접속해서 사이트를 등록한다.\n- 좌측 사이드바 메뉴에서 요청 - 사이트맵 제출에서 sitemap.xml의 경로를 입력한다.\n- 요청 - RSS 제출에서도 마찬가지로 경로를 입력한다.\n- 검증 - robots.txt에서 robots.txt 검증 및 수집요청을 한다.\n- 설정 - 수집 주기 설정을 빠르게를 체크한다.\n모든 등록이 끝났으면 몇시간뒤에 검색창에서 `site: 블로그주소`를 입력해서 등록됬는지 확인한다.\n\n## 다음 검색 노출\n다음은 다른 검색엔진보다 매우 간단해서.\nhttps://register.search.daum.net/index.daum에 접속해서 블로그를 등록만하면 끝이다.\n\n\n# 끝으로\n이렇게 간단하게 겟츠비를 통해서 블로그를 만들고 SEO 적용까지 해봤다.\n생략된 부분도 많지만 충분히 참고할 수 있을 것이다.\nReact를 잘 사용하거나 앞으로 사용해야하는 개발자가 블로그를 만들게 된다면\nGatsby로 만들어보는 것을 추천한다. 테마로 만들어도 되지만 자신이 직접 react로 만들어도 좋을것이다.\n<br>\n만약에 블로그를 수정하다가 `npm` 관련 오류가 발생한다면, yarn으로 전환해서 구축하거나,\nnpm 패키지를 재설치 해보자.\n\n\n","excerpt":"처음에는 Jekyll로 블로그를 만들었는데 생각보다 마음에 안들어서, 검색하다보니 Gatsby를 발견했다.\nGatsby는  프레임워크를 기반으로 만들었는데 React를 전에 한번 입문해봐서 이걸로 선택했다.\n\n\n처음에는 으로 node module를 …","fields":{"slug":"/gatsby-blog-start/"},"frontmatter":{"date":"Sep 28, 2021","title":"Gatsby로 블로그를 만들기","tags":["Gatsby","Blog"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n#application.properties\n\n스프링 애플리케이션은 다음 리소스가 주어진 순서대로 고려된다.\n\n1. 명령행 인수\n2. 패키징된 애플리케이션 외부의 `application.properties`\n3. 패키징된 애플리케이션 내부의 `application.properties`\n\napplication-{profile}.properties는 프로필에 관련되지 않은 파일 보다 우선된다.\n\n1. 명령행 인수\n2. 패키징된 애플리케이션 외부의 `application-{profile}.properties`\n3. 패키징된 애플리케이션 외부의 `application.properties`\n4. 패키징된 애플리케이션 내부의 `application-{profile}.properties`\n5. 패키징된 애플리케이션 내부의 `application.properties`\n\n##application.properties 에서 속성 값 사용하기\n속성 외부화를 위해 우리가 만든 application.properties를 사용할려면 `@Value` 어노테이션을 사용해야한다.\n`@Value` 어노테이션은 스프링이 속성을 찾고 해당 속성의 값을 사용하도록 지시한다.\n\n```java\npublic 리턴타입 메소드(@Value(\"${hi}\") int hi) {\n  ...\n}\n```\n\n스프링은 hi라는 이름을 가진 속성을 감지하고 그 값을 사용한다.\n\n또한 `:`을 사용해 기본값을 지정할 수 있다.\n\n```java\npublic 리턴타입 메소드(@Value(\"${hi:10}\") int hi) {\n  ...\n}\n```\n\n만약 `:` 기본값을 지정하면 값을 찾지 못했을 때 10을 기본값으로 사용한다.\n기본값을 정의하지 않고, 해당 속성이 없을 때 `IllegalArgumentException`이 발생한다.\n\n##프로필을 사용한 속성 재정의\n스프링 부트는 프로필을 사용해 추가 구성 파일을 불러와 기존의 application.properties를 전부 대체 또는 일부를 재정의할 수 있다.\n`application-{profile}.properties`를 만들면 된다.\n만약에 `application.properties`에 `hi` 값이 있고, `application-hi.properties`에 `hi`라는 값이 있으면\n`application-hi.properties`의 속성 우선순위가 높기 때문에 대체된다.\n\n##다른 속성 파일로부터 속성 불러오기\n내가 사용하고 싶은 속성 파일을 불러오고자 하면은, `@SpringBootApplication` 어노테이션이 붙은 클래스에\n`@PropertySource` 어노테이션을 추가해 사용할 수 있다.\n\n```java\n@PropertySource(\"classpath:임의의속성파일.properties\")\n@SpringBootApplication\npublic class MySpringApp {\n...\n}\n```\n\n`@PropertySource` 어노테이션은 스프링부트가 시작할 때 추가 속성 파일을 불러와준다.\n해당 어노테이션 대신 밑에 표의 매개변수를 사용하면 스프링 부트가 추가 속성 파일을 불러온다.\n\n| 매개변수                          |                         설명 |\n| :-------------------------------- | ---------------------------: |\n| spring.config.name                |             불러올 파일 목록 |\n| spring.config.location            |             속성 파일의 위치 |\n| spring.config.additional-location | 속성 파일을 불러올 추가 위치 |\n\n위 매개변수를 사용하면, application.properties는 불러오지 않는다.\n모두 검색하는 방법으로는 `--spring.config.name=application,불러올속성파일`을 사용한다.","excerpt":"application.properties 스프링 애플리케이션은 다음 리소스가 주어진 순서대로 고려된다. 명령행 인수 패키징된 애플리케이션 외부의  패키징된 애플리케이션 내부의  application-{profile}.properties는 프로필에 관…","fields":{"slug":"/springboot-application-properties-extern/"},"frontmatter":{"date":"Sep 27, 2021","title":"[SpringBoot] 속성 외부화","tags":["SpringBoot","속성","Properties"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}